{"ast":null,"code":"const {\n  _subtype,\n  _decorator,\n  _callAbstract,\n  _is,\n  _$name\n} = require('./compile/protypes');\n/**\n * Copy properties from prototypes into the class's prototype.\n * The target class's prototype is modified itself.\n * @param {new (...args: *[]) => Object} TargetClass The class whose prototype should be updated with methods from implementations.\n * @param {Options} opts Options for extending.\n * - `[methodDecorators]` _!Array&lt;!$decorator&gt;\\|$decorator?_ An array with functions that will decorate methods when new descriptors\n * get assigned to the prototype of a target.\n * - `[setProtypesPrototype=false]` _boolean?_ When passing protypes, set target's prototype as their own, so that\n * `super` calls can be made. This will update the protype's prototype\n * every time the `subtype` method is called on them, so this should be\n * used only when a class is subtyped once. Default `false`.\n * - `[mergeGettersSetters=false]` _boolean?_ When copying getters and setters that are missing their counterpart, find\n * their sibling in the prototype chain and fill in the slot. If this is not\n * done, a single getter without setter will prevent a setter from being\n * called on a parent class. Default `false`.\n * - `[fixTargetGettersSetters]` _'before'\\|'after'\\|true?_ Looks up the prototypical chain of the target to merge its getters and\n * setters with missing counterparts, if such are found. This allows to inherit\n * individual getters and setters. The value can be either `before` or `after`,\n * such that the fix will be performed either before or after subtyping. If it\n * is done before, then no subtype will be able to fill in the slot, and if\n * after, then if any supertype had filled in the slot, it won't be updated.\n * When passing a boolean `true`, the `before` strategy is chosen.\n * - `[bindings]` _!BindingOptions?_ Options for binding methods. When binding is enabled, all methods of applicable\n * instances will be re-described with `get` property of the field descriptor,\n * which wraps the actual method (its `value` property) to return the bound one.\n * This feature is available only in the `paid` version.\n * - `[overrideTarget=false]` _boolean?_ When protypes' methods are already present in the target, override them.\n * By default, this option is set to false which means that all methods on the\n * target will have precedence over those found in protypes. Default `false`.\n * @param {...!Object<string, *>|function(new: Object, ...*)} Implementations The implementations in form of protypes or constructors.\n * @example\n * ```js\n * import { subtype } from 'protypes'\n *\n * ```\n * This is the class that will be extended (subtyped):\n * ```js\n * class Target {}\n *\n * ```\n * The supertype from whose prototype properties will be compied:\n * ```js\n * class Specialised {\n *   get example() {\n *     return 'hello-world'\n *   }\n * }\n * ```\n * Instead of full class, a simple object (protype) can be used:\n * ```js\n * let Protype = {\n *   example2() { return 'protype run' },\n * }\n *\n * subtype(Target, null, Specialised, Protype)\n * const t = new Target()\n *\n * console.log(t.example)\n * ```\n * \"hello world\" - from `Specialised`\n * ```js\n * console.log(t.example2())\n * ```\n * \"protype run\" - from `Protype`\n * @return {void} Doesn't return anything. Updates the class directly.\n */\n\n\nfunction $subtype(TargetClass, opts, ...Implementations) {\n  return _subtype(TargetClass, opts, ...Implementations);\n}\n/**\n * Method decorators will be called prior to assigning a new descriptor on the\n * target's prototype and allow to set up pre- and post- logic on methods.\n * This is just a signature type and not a real function.\n * @param {!Function} method The method that potentially can be decorated.\n * @param {string} propName The name of the member slot which is being assigned.\n * @param {!Object} target This is the prototype on which the descriptor will be assigned.\n * @return {Function} The decorated function or null.\n */\n\n\nfunction $decorator(method, propName, target) {\n  return _decorator(method, propName, target);\n}\n/**\n * This decorator will call immediate ABC (abstract) class that is extended\n * by the target class. Can be used for run-time type checking.\n * @param {!Function} method The method that potentially can be decorated.\n * @param {string} propName The name of the member slot which is being assigned.\n * @param {!Object} target This is the prototype on which the descriptor will be assigned.\n * @return {Function} The decorated function or null.\n */\n\n\nfunction $callAbstract(method, propName, target) {\n  return _callAbstract(method, propName, target);\n}\n/**\n * Checks whether the instance was created by a constructor which\n * has been subtyped with a protype or class that was assigned the\n * `name` symbol from this library.\n * @param {!Object} instance The instance that was subtyped with `protypes` to check the kind of.\n * @param {string} kind The required kind that should be checked.\n * @return {boolean} True if the instance is of the kind given and false otherwise.\n */\n\n\nfunction $is(instance, kind) {\n  return _is(instance, kind);\n}\n\nmodule.exports.$name = _$name;\nmodule.exports.subtype = $subtype;\nmodule.exports.decorator = $decorator;\nmodule.exports.callAbstract = $callAbstract;\nmodule.exports.is = $is;\n/**\n * @typedef {$subtype} subtype\n * @typedef {$decorator} decorator\n * @typedef {$callAbstract} callAbstract\n * @typedef {$is} is\n */\n\n/* typal types/index.xml */\n\n/**\n * @typedef {Object} Options `＠record` The options used in the library.\n * @prop {!Array<!$decorator>|$decorator} [methodDecorators] An array with functions that will decorate methods when new descriptors\n * get assigned to the prototype of a target.\n * @prop {boolean} [setProtypesPrototype=false] When passing protypes, set target's prototype as their own, so that\n * `super` calls can be made. This will update the protype's prototype\n * every time the `subtype` method is called on them, so this should be\n * used only when a class is subtyped once. Default `false`.\n * @prop {boolean} [mergeGettersSetters=false] When copying getters and setters that are missing their counterpart, find\n * their sibling in the prototype chain and fill in the slot. If this is not\n * done, a single getter without setter will prevent a setter from being\n * called on a parent class. Default `false`.\n * @prop {'before'|'after'|true} [fixTargetGettersSetters] Looks up the prototypical chain of the target to merge its getters and\n * setters with missing counterparts, if such are found. This allows to inherit\n * individual getters and setters. The value can be either `before` or `after`,\n * such that the fix will be performed either before or after subtyping. If it\n * is done before, then no subtype will be able to fill in the slot, and if\n * after, then if any supertype had filled in the slot, it won't be updated.\n * When passing a boolean `true`, the `before` strategy is chosen.\n * @prop {!BindingOptions} [bindings] Options for binding methods. When binding is enabled, all methods of applicable\n * instances will be re-described with `get` property of the field descriptor,\n * which wraps the actual method (its `value` property) to return the bound one.\n * This feature is available only in the `paid` version.\n * @prop {boolean} [overrideTarget=false] When protypes' methods are already present in the target, override them.\n * By default, this option is set to false which means that all methods on the\n * target will have precedence over those found in protypes. Default `false`.\n * @typedef {Object} BindingOptions `＠record` Options to bind methods to instances.\n * @prop {boolean} [bindMethods=false] Binds all methods:\n * - in protypes and classes, i.e. structs passed to the `subtype` method.\n * - in target's own properties.\n * - in the whole of target's inheritance chain so that any inherited method is also bound. Default `false`.\n * @prop {boolean} [bindProtypeMethods=false] Binds protypes' methods to the instance. Default `false`.\n * @prop {boolean} [bindClassMethods=false] Binds methods of classes passed to `subtype` to the instance. Default `false`.\n * @prop {boolean} [bindTargetMethods=false] Allows to bind methods to the target to their instance even prior to instantiating. Default `false`.\n * @prop {boolean} [bindInhertiedMethods=false] Scans through the inheritance chain of the target (and supertype classes) and wraps\n * methods in getters that will return their bound versions. Default `false`.\n * @typedef {!Symbol} $name The symbol to be used to assign name to protypes and classes to check using\n * the is method afterwards.\n */","map":{"version":3,"sources":["/Users/samtoll/Desktop/FinalProject/react-app/node_modules/protypes/index.js"],"names":["_subtype","_decorator","_callAbstract","_is","_$name","require","$subtype","TargetClass","opts","Implementations","$decorator","method","propName","target","$callAbstract","$is","instance","kind","module","exports","$name","subtype","decorator","callAbstract","is"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,QAAF;AAAYC,EAAAA,UAAZ;AAAwBC,EAAAA,aAAxB;AAAuCC,EAAAA,GAAvC;AAA4CC,EAAAA;AAA5C,IAAuDC,OAAO,CAAC,oBAAD,CAApE;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,QAAT,CAAkBC,WAAlB,EAA+BC,IAA/B,EAAqC,GAAGC,eAAxC,EAAyD;AACvD,SAAOT,QAAQ,CAACO,WAAD,EAAcC,IAAd,EAAoB,GAAGC,eAAvB,CAAf;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,QAA5B,EAAsCC,MAAtC,EAA8C;AAC5C,SAAOZ,UAAU,CAACU,MAAD,EAASC,QAAT,EAAmBC,MAAnB,CAAjB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAuBH,MAAvB,EAA+BC,QAA/B,EAAyCC,MAAzC,EAAiD;AAC/C,SAAOX,aAAa,CAACS,MAAD,EAASC,QAAT,EAAmBC,MAAnB,CAApB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,GAAT,CAAaC,QAAb,EAAuBC,IAAvB,EAA6B;AAC3B,SAAOd,GAAG,CAACa,QAAD,EAAWC,IAAX,CAAV;AACD;;AAEDC,MAAM,CAACC,OAAP,CAAeC,KAAf,GAAuBhB,MAAvB;AAEAc,MAAM,CAACC,OAAP,CAAeE,OAAf,GAAyBf,QAAzB;AACAY,MAAM,CAACC,OAAP,CAAeG,SAAf,GAA2BZ,UAA3B;AACAQ,MAAM,CAACC,OAAP,CAAeI,YAAf,GAA8BT,aAA9B;AACAI,MAAM,CAACC,OAAP,CAAeK,EAAf,GAAoBT,GAApB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["const { _subtype, _decorator, _callAbstract, _is, _$name } = require('./compile/protypes')\n\n/**\n * Copy properties from prototypes into the class's prototype.\n * The target class's prototype is modified itself.\n * @param {new (...args: *[]) => Object} TargetClass The class whose prototype should be updated with methods from implementations.\n * @param {Options} opts Options for extending.\n * - `[methodDecorators]` _!Array&lt;!$decorator&gt;\\|$decorator?_ An array with functions that will decorate methods when new descriptors\n * get assigned to the prototype of a target.\n * - `[setProtypesPrototype=false]` _boolean?_ When passing protypes, set target's prototype as their own, so that\n * `super` calls can be made. This will update the protype's prototype\n * every time the `subtype` method is called on them, so this should be\n * used only when a class is subtyped once. Default `false`.\n * - `[mergeGettersSetters=false]` _boolean?_ When copying getters and setters that are missing their counterpart, find\n * their sibling in the prototype chain and fill in the slot. If this is not\n * done, a single getter without setter will prevent a setter from being\n * called on a parent class. Default `false`.\n * - `[fixTargetGettersSetters]` _'before'\\|'after'\\|true?_ Looks up the prototypical chain of the target to merge its getters and\n * setters with missing counterparts, if such are found. This allows to inherit\n * individual getters and setters. The value can be either `before` or `after`,\n * such that the fix will be performed either before or after subtyping. If it\n * is done before, then no subtype will be able to fill in the slot, and if\n * after, then if any supertype had filled in the slot, it won't be updated.\n * When passing a boolean `true`, the `before` strategy is chosen.\n * - `[bindings]` _!BindingOptions?_ Options for binding methods. When binding is enabled, all methods of applicable\n * instances will be re-described with `get` property of the field descriptor,\n * which wraps the actual method (its `value` property) to return the bound one.\n * This feature is available only in the `paid` version.\n * - `[overrideTarget=false]` _boolean?_ When protypes' methods are already present in the target, override them.\n * By default, this option is set to false which means that all methods on the\n * target will have precedence over those found in protypes. Default `false`.\n * @param {...!Object<string, *>|function(new: Object, ...*)} Implementations The implementations in form of protypes or constructors.\n * @example\n * ```js\n * import { subtype } from 'protypes'\n *\n * ```\n * This is the class that will be extended (subtyped):\n * ```js\n * class Target {}\n *\n * ```\n * The supertype from whose prototype properties will be compied:\n * ```js\n * class Specialised {\n *   get example() {\n *     return 'hello-world'\n *   }\n * }\n * ```\n * Instead of full class, a simple object (protype) can be used:\n * ```js\n * let Protype = {\n *   example2() { return 'protype run' },\n * }\n *\n * subtype(Target, null, Specialised, Protype)\n * const t = new Target()\n *\n * console.log(t.example)\n * ```\n * \"hello world\" - from `Specialised`\n * ```js\n * console.log(t.example2())\n * ```\n * \"protype run\" - from `Protype`\n * @return {void} Doesn't return anything. Updates the class directly.\n */\nfunction $subtype(TargetClass, opts, ...Implementations) {\n  return _subtype(TargetClass, opts, ...Implementations)\n}\n\n/**\n * Method decorators will be called prior to assigning a new descriptor on the\n * target's prototype and allow to set up pre- and post- logic on methods.\n * This is just a signature type and not a real function.\n * @param {!Function} method The method that potentially can be decorated.\n * @param {string} propName The name of the member slot which is being assigned.\n * @param {!Object} target This is the prototype on which the descriptor will be assigned.\n * @return {Function} The decorated function or null.\n */\nfunction $decorator(method, propName, target) {\n  return _decorator(method, propName, target)\n}\n\n/**\n * This decorator will call immediate ABC (abstract) class that is extended\n * by the target class. Can be used for run-time type checking.\n * @param {!Function} method The method that potentially can be decorated.\n * @param {string} propName The name of the member slot which is being assigned.\n * @param {!Object} target This is the prototype on which the descriptor will be assigned.\n * @return {Function} The decorated function or null.\n */\nfunction $callAbstract(method, propName, target) {\n  return _callAbstract(method, propName, target)\n}\n\n/**\n * Checks whether the instance was created by a constructor which\n * has been subtyped with a protype or class that was assigned the\n * `name` symbol from this library.\n * @param {!Object} instance The instance that was subtyped with `protypes` to check the kind of.\n * @param {string} kind The required kind that should be checked.\n * @return {boolean} True if the instance is of the kind given and false otherwise.\n */\nfunction $is(instance, kind) {\n  return _is(instance, kind)\n}\n\nmodule.exports.$name = _$name\n\nmodule.exports.subtype = $subtype\nmodule.exports.decorator = $decorator\nmodule.exports.callAbstract = $callAbstract\nmodule.exports.is = $is\n\n/**\n * @typedef {$subtype} subtype\n * @typedef {$decorator} decorator\n * @typedef {$callAbstract} callAbstract\n * @typedef {$is} is\n */\n\n/* typal types/index.xml */\n/**\n * @typedef {Object} Options `＠record` The options used in the library.\n * @prop {!Array<!$decorator>|$decorator} [methodDecorators] An array with functions that will decorate methods when new descriptors\n * get assigned to the prototype of a target.\n * @prop {boolean} [setProtypesPrototype=false] When passing protypes, set target's prototype as their own, so that\n * `super` calls can be made. This will update the protype's prototype\n * every time the `subtype` method is called on them, so this should be\n * used only when a class is subtyped once. Default `false`.\n * @prop {boolean} [mergeGettersSetters=false] When copying getters and setters that are missing their counterpart, find\n * their sibling in the prototype chain and fill in the slot. If this is not\n * done, a single getter without setter will prevent a setter from being\n * called on a parent class. Default `false`.\n * @prop {'before'|'after'|true} [fixTargetGettersSetters] Looks up the prototypical chain of the target to merge its getters and\n * setters with missing counterparts, if such are found. This allows to inherit\n * individual getters and setters. The value can be either `before` or `after`,\n * such that the fix will be performed either before or after subtyping. If it\n * is done before, then no subtype will be able to fill in the slot, and if\n * after, then if any supertype had filled in the slot, it won't be updated.\n * When passing a boolean `true`, the `before` strategy is chosen.\n * @prop {!BindingOptions} [bindings] Options for binding methods. When binding is enabled, all methods of applicable\n * instances will be re-described with `get` property of the field descriptor,\n * which wraps the actual method (its `value` property) to return the bound one.\n * This feature is available only in the `paid` version.\n * @prop {boolean} [overrideTarget=false] When protypes' methods are already present in the target, override them.\n * By default, this option is set to false which means that all methods on the\n * target will have precedence over those found in protypes. Default `false`.\n * @typedef {Object} BindingOptions `＠record` Options to bind methods to instances.\n * @prop {boolean} [bindMethods=false] Binds all methods:\n * - in protypes and classes, i.e. structs passed to the `subtype` method.\n * - in target's own properties.\n * - in the whole of target's inheritance chain so that any inherited method is also bound. Default `false`.\n * @prop {boolean} [bindProtypeMethods=false] Binds protypes' methods to the instance. Default `false`.\n * @prop {boolean} [bindClassMethods=false] Binds methods of classes passed to `subtype` to the instance. Default `false`.\n * @prop {boolean} [bindTargetMethods=false] Allows to bind methods to the target to their instance even prior to instantiating. Default `false`.\n * @prop {boolean} [bindInhertiedMethods=false] Scans through the inheritance chain of the target (and supertype classes) and wraps\n * methods in getters that will return their bound versions. Default `false`.\n * @typedef {!Symbol} $name The symbol to be used to assign name to protypes and classes to check using\n * the is method afterwards.\n */\n"]},"metadata":{},"sourceType":"script"}