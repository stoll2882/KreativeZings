{"ast":null,"code":"import { jsxs, jsx, Fragment } from 'react/jsx-runtime';\nimport { useCallback, useRef, useEffect, useState, useLayoutEffect, useMemo, cloneElement, memo, forwardRef, useImperativeHandle } from 'react';\nimport clsx from 'clsx';\nimport { createPortal } from 'react-dom';\n\nfunction useCombinedRefs(...refs) {\n  return useCallback(handle => {\n    for (const ref of refs) {\n      if (typeof ref === 'function') {\n        ref(handle);\n      } else if (ref !== null) {\n        ref.current = handle;\n      }\n    }\n  }, refs);\n}\n\nfunction useClickOutside(onClick) {\n  const frameRequestRef = useRef();\n\n  function cancelAnimationFrameRequest() {\n    if (typeof frameRequestRef.current === 'number') {\n      cancelAnimationFrame(frameRequestRef.current);\n      frameRequestRef.current = undefined;\n    }\n  }\n\n  const onClickRef = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  useEffect(() => {\n    onClickRef.current = onClick;\n  });\n  useEffect(() => {\n    function onOutsideClick() {\n      frameRequestRef.current = undefined;\n      onClickRef.current();\n    }\n\n    function onWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      frameRequestRef.current = requestAnimationFrame(onOutsideClick);\n    }\n\n    window.addEventListener('click', onWindowCaptureClick, {\n      capture: true\n    });\n    return () => {\n      window.removeEventListener('click', onWindowCaptureClick, {\n        capture: true\n      });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n  return cancelAnimationFrameRequest;\n}\n\nfunction useGridDimensions() {\n  const gridRef = useRef(null);\n  const [gridWidth, setGridWidth] = useState(1);\n  const [gridHeight, setGridHeight] = useState(1);\n  useLayoutEffect(() => {\n    const {\n      ResizeObserver\n    } = window;\n    if (ResizeObserver == null) return;\n    const resizeObserver = new ResizeObserver(entries => {\n      const {\n        width,\n        height\n      } = entries[0].contentRect;\n      setGridWidth(width);\n      setGridHeight(height);\n    });\n    resizeObserver.observe(gridRef.current);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n  return [gridRef, gridWidth, gridHeight];\n}\n\nfunction useFocusRef(isCellSelected) {\n  const ref = useRef(null);\n  useLayoutEffect(() => {\n    var _ref$current;\n\n    if (!isCellSelected) return;\n    (_ref$current = ref.current) == null ? void 0 : _ref$current.focus({\n      preventScroll: true\n    });\n  }, [isCellSelected]);\n  return ref;\n}\n\nfunction SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onClick,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}) {\n  const inputRef = useFocusRef(isCellSelected);\n\n  function handleChange(e) {\n    onChange(e.target.checked, e.nativeEvent.shiftKey);\n  }\n\n  return /*#__PURE__*/jsxs(\"label\", {\n    className: 'rdg-checkbox-label' + (disabled ? \" rdg-checkbox-label-disabled\" : \"\"),\n    children: [/*#__PURE__*/jsx(\"input\", {\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      tabIndex: tabIndex,\n      ref: inputRef,\n      type: \"checkbox\",\n      className: \"rdg-checkbox-input\",\n      disabled: disabled,\n      checked: value,\n      onChange: handleChange,\n      onClick: onClick\n    }), /*#__PURE__*/jsx(\"div\", {\n      className: \"rdg-checkbox\"\n    })]\n  });\n}\n\nfunction ValueFormatter(props) {\n  try {\n    return /*#__PURE__*/jsx(Fragment, {\n      children: props.row[props.column.key]\n    });\n  } catch {\n    return null;\n  }\n}\n\nfunction ToggleGroupFormatter({\n  groupKey,\n  isExpanded,\n  isCellSelected,\n  toggleGroup\n}) {\n  const cellRef = useFocusRef(isCellSelected);\n\n  function handleKeyDown({\n    key\n  }) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n  return /*#__PURE__*/jsxs(\"span\", {\n    ref: cellRef,\n    className: \"rdg-group-cell-content\",\n    tabIndex: -1,\n    onKeyDown: handleKeyDown,\n    children: [groupKey, /*#__PURE__*/jsx(\"svg\", {\n      viewBox: \"0 0 14 8\",\n      width: \"14\",\n      height: \"8\",\n      className: \"rdg-caret\",\n      children: /*#__PURE__*/jsx(\"path\", {\n        d: d\n      })\n    })]\n  });\n}\n\nfunction stopPropagation(event) {\n  event.stopPropagation();\n}\n\nfunction wrapEvent(ourHandler, theirHandler) {\n  if (theirHandler === undefined) return ourHandler;\n  return function (event) {\n    ourHandler(event);\n    theirHandler(event);\n  };\n}\n\nconst SELECT_COLUMN_KEY = 'select-row';\nconst SelectColumn = {\n  key: SELECT_COLUMN_KEY,\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  resizable: false,\n  sortable: false,\n  frozen: true,\n\n  headerRenderer(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select All\",\n      value: props.allRowsSelected,\n      onChange: props.onAllRowsSelectionChange\n    });\n  },\n\n  formatter(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select\",\n      tabIndex: -1,\n      isCellSelected: props.isCellSelected,\n      value: props.isRowSelected,\n      onClick: stopPropagation,\n      onChange: props.onRowSelectionChange\n    });\n  },\n\n  groupFormatter(props) {\n    return /*#__PURE__*/jsx(SelectCellFormatter, {\n      \"aria-label\": \"Select Group\",\n      tabIndex: -1,\n      isCellSelected: props.isCellSelected,\n      value: props.isRowSelected,\n      onChange: props.onRowSelectionChange,\n      onClick: stopPropagation\n    });\n  }\n\n};\n\nfunction useViewportColumns({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy\n}) {\n  var _defaultColumnOptions, _defaultColumnOptions2, _defaultColumnOptions3, _defaultColumnOptions4;\n\n  const minColumnWidth = (_defaultColumnOptions = defaultColumnOptions == null ? void 0 : defaultColumnOptions.minWidth) != null ? _defaultColumnOptions : 80;\n  const defaultFormatter = (_defaultColumnOptions2 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.formatter) != null ? _defaultColumnOptions2 : ValueFormatter;\n  const defaultSortable = (_defaultColumnOptions3 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.sortable) != null ? _defaultColumnOptions3 : false;\n  const defaultResizable = (_defaultColumnOptions4 = defaultColumnOptions == null ? void 0 : defaultColumnOptions.resizable) != null ? _defaultColumnOptions4 : false;\n  const {\n    columns,\n    lastFrozenColumnIndex,\n    totalColumnWidth,\n    totalFrozenColumnWidth,\n    groupBy\n  } = useMemo(() => {\n    let left = 0;\n    let totalWidth = 0;\n    let allocatedWidths = 0;\n    let unassignedColumnsCount = 0;\n    let lastFrozenColumnIndex = -1;\n    let totalFrozenColumnWidth = 0;\n    const columns = rawColumns.map(metricsColumn => {\n      let width = getSpecifiedWidth(metricsColumn, columnWidths, viewportWidth);\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        width = clampColumnWidth(width, metricsColumn, minColumnWidth);\n        allocatedWidths += width;\n      }\n\n      const column = { ...metricsColumn,\n        width\n      };\n\n      if (rawGroupBy == null ? void 0 : rawGroupBy.includes(column.key)) {\n        column.frozen = true;\n        column.rowGroup = true;\n      }\n\n      if (column.frozen) {\n        lastFrozenColumnIndex++;\n      }\n\n      return column;\n    });\n    columns.sort(({\n      key: aKey,\n      frozen: frozenA\n    }, {\n      key: bKey,\n      frozen: frozenB\n    }) => {\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      if (rawGroupBy == null ? void 0 : rawGroupBy.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n\n        return -1;\n      }\n\n      if (rawGroupBy == null ? void 0 : rawGroupBy.includes(bKey)) return 1;\n\n      if (frozenA) {\n        if (frozenB) return 0;\n        return -1;\n      }\n\n      if (frozenB) return 1;\n      return 0;\n    });\n    const unallocatedWidth = viewportWidth - allocatedWidths;\n    const unallocatedColumnWidth = Math.max(Math.floor(unallocatedWidth / unassignedColumnsCount), minColumnWidth);\n    const groupBy = [];\n    const calculatedColumns = columns.map((column, idx) => {\n      var _column$width, _column$sortable, _column$resizable, _column$formatter;\n\n      const width = (_column$width = column.width) != null ? _column$width : clampColumnWidth(unallocatedColumnWidth, column, minColumnWidth);\n      const newColumn = { ...column,\n        idx,\n        width,\n        left,\n        sortable: (_column$sortable = column.sortable) != null ? _column$sortable : defaultSortable,\n        resizable: (_column$resizable = column.resizable) != null ? _column$resizable : defaultResizable,\n        formatter: (_column$formatter = column.formatter) != null ? _column$formatter : defaultFormatter\n      };\n\n      if (newColumn.rowGroup) {\n        var _column$groupFormatte;\n\n        groupBy.push(column.key);\n        newColumn.groupFormatter = (_column$groupFormatte = column.groupFormatter) != null ? _column$groupFormatte : ToggleGroupFormatter;\n      }\n\n      totalWidth += width;\n      left += width;\n      return newColumn;\n    });\n\n    if (lastFrozenColumnIndex !== -1) {\n      const lastFrozenColumn = calculatedColumns[lastFrozenColumnIndex];\n      lastFrozenColumn.isLastFrozenColumn = true;\n      totalFrozenColumnWidth = lastFrozenColumn.left + lastFrozenColumn.width;\n    }\n\n    return {\n      columns: calculatedColumns,\n      lastFrozenColumnIndex,\n      totalFrozenColumnWidth,\n      totalColumnWidth: totalWidth,\n      groupBy\n    };\n  }, [columnWidths, defaultFormatter, defaultResizable, defaultSortable, minColumnWidth, rawColumns, rawGroupBy, viewportWidth]);\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo(() => {\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n    while (colVisibleStartIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columns[colVisibleStartIdx];\n\n      if (left + width > viewportLeft) {\n        break;\n      }\n\n      colVisibleStartIdx++;\n    }\n\n    let colVisibleEndIdx = colVisibleStartIdx;\n\n    while (colVisibleEndIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columns[colVisibleEndIdx];\n\n      if (left + width >= viewportRight) {\n        break;\n      }\n\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n  const viewportColumns = useMemo(() => {\n    const viewportColumns = [];\n\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n  return {\n    columns,\n    viewportColumns,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  };\n}\n\nfunction getSpecifiedWidth({\n  key,\n  width\n}, columnWidths, viewportWidth) {\n  if (columnWidths.has(key)) {\n    return columnWidths.get(key);\n  }\n\n  if (typeof width === 'number') {\n    return width;\n  }\n\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n\n  return undefined;\n}\n\nfunction clampColumnWidth(width, {\n  minWidth,\n  maxWidth\n}, minColumnWidth) {\n  width = Math.max(width, minWidth != null ? minWidth : minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n\nconst RENDER_BACTCH_SIZE = 8;\n\nfunction useViewportRows({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows, [groupByKey, ...remainingGroupByKeys], startRowIndex) => {\n      let groupRowsCount = 0;\n      const groups = {};\n\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [childRows, childRows.length] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1);\n        groups[key] = {\n          childRows,\n          childGroups,\n          startRowIndex: startRowIndex + groupRowsCount\n        };\n        groupRowsCount += childRowsCount + 1;\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set();\n    if (!groupedRows) return [rawRows, allGroupRows];\n    const flattenedRows = [];\n\n    const expandGroup = (rows, parentId, level) => {\n      if (Array.isArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        var _expandedGroupIds$has;\n\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = (_expandedGroupIds$has = expandedGroupIds == null ? void 0 : expandedGroupIds.has(id)) != null ? _expandedGroupIds$has : false;\n        const {\n          childRows,\n          childGroups,\n          startRowIndex\n        } = rows[groupKey];\n        const groupRow = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = row => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}\n\nfunction useLatestFunc(fn) {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  });\n  return useCallback((...args) => {\n    ref.current(...args);\n  }, []);\n}\n\nconst SORT_TEXT = {\n  ASC: '\\u25B2',\n  DESC: '\\u25BC',\n  NONE: ''\n};\n\nfunction SortableHeaderCell({\n  column,\n  onSort,\n  sortColumn,\n  sortDirection,\n  children\n}) {\n  sortDirection = sortColumn === column.key && sortDirection || 'NONE';\n\n  function onClick() {\n    if (!onSort) return;\n    const {\n      sortDescendingFirst\n    } = column;\n    let direction;\n\n    switch (sortDirection) {\n      case 'ASC':\n        direction = sortDescendingFirst ? 'NONE' : 'DESC';\n        break;\n\n      case 'DESC':\n        direction = sortDescendingFirst ? 'ASC' : 'NONE';\n        break;\n\n      default:\n        direction = sortDescendingFirst ? 'DESC' : 'ASC';\n        break;\n    }\n\n    onSort(column.key, direction);\n  }\n\n  return /*#__PURE__*/jsxs(\"span\", {\n    className: \"rdg-header-sort-cell\",\n    onClick: onClick,\n    children: [/*#__PURE__*/jsx(\"span\", {\n      className: \"rdg-header-sort-name\",\n      children: children\n    }), /*#__PURE__*/jsx(\"span\", {\n      children: SORT_TEXT[sortDirection]\n    })]\n  });\n}\n\nfunction ResizableHeaderCell({\n  children,\n  column,\n  onResize\n}) {\n  function onMouseDown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const {\n      currentTarget\n    } = event;\n    const {\n      right\n    } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) {\n      return;\n    }\n\n    const onMouseMove = event => {\n      handleResize(event.clientX + offset, currentTarget);\n    };\n\n    const onMouseUp = () => {\n      window.removeEventListener('mousemove', onMouseMove);\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    event.preventDefault();\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  }\n\n  function onTouchStart(event) {\n    const touch = event.changedTouches[0];\n    const {\n      identifier\n    } = touch;\n    const {\n      currentTarget\n    } = event;\n    const {\n      right\n    } = currentTarget.getBoundingClientRect();\n    const offset = right - touch.clientX;\n\n    if (offset > 11) {\n      return;\n    }\n\n    function getTouch(event) {\n      for (const touch of event.changedTouches) {\n        if (touch.identifier === identifier) return touch;\n      }\n\n      return null;\n    }\n\n    const onTouchMove = event => {\n      const touch = getTouch(event);\n\n      if (touch) {\n        handleResize(touch.clientX + offset, currentTarget);\n      }\n    };\n\n    const onTouchEnd = event => {\n      const touch = getTouch(event);\n      if (!touch) return;\n      window.removeEventListener('touchmove', onTouchMove);\n      window.removeEventListener('touchend', onTouchEnd);\n    };\n\n    window.addEventListener('touchmove', onTouchMove);\n    window.addEventListener('touchend', onTouchEnd);\n  }\n\n  function handleResize(x, target) {\n    const width = x - target.getBoundingClientRect().left;\n\n    if (width > 0) {\n      onResize(column, width);\n    }\n  }\n\n  return /*#__PURE__*/cloneElement(children, {\n    onMouseDown,\n    onTouchStart\n  });\n}\n\nfunction getAriaSort(sortDirection) {\n  switch (sortDirection) {\n    case 'ASC':\n      return 'ascending';\n\n    case 'DESC':\n      return 'descending';\n\n    default:\n      return 'none';\n  }\n}\n\nfunction HeaderCell({\n  column,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumn,\n  sortDirection,\n  onSort\n}) {\n  function getCell() {\n    if (column.headerRenderer) {\n      return /*#__PURE__*/jsx(column.headerRenderer, {\n        column: column,\n        sortColumn: sortColumn,\n        sortDirection: sortDirection,\n        onSort: onSort,\n        allRowsSelected: allRowsSelected,\n        onAllRowsSelectionChange: onAllRowsSelectionChange\n      });\n    }\n\n    if (column.sortable) {\n      return /*#__PURE__*/jsx(SortableHeaderCell, {\n        column: column,\n        onSort: onSort,\n        sortColumn: sortColumn,\n        sortDirection: sortDirection,\n        children: column.name\n      });\n    }\n\n    return column.name;\n  }\n\n  let cell = getCell();\n  const className = clsx('rdg-cell', column.headerCellClass, column.resizable && 'rdg-cell-resizable', column.frozen && 'rdg-cell-frozen', column.isLastFrozenColumn && 'rdg-cell-frozen-last');\n  const style = {\n    width: column.width,\n    left: column.left\n  };\n  cell = /*#__PURE__*/jsx(\"div\", {\n    role: \"columnheader\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-sort\": sortColumn === column.key ? getAriaSort(sortDirection) : undefined,\n    className: className,\n    style: style,\n    children: cell\n  });\n\n  if (column.resizable) {\n    cell = /*#__PURE__*/jsx(ResizableHeaderCell, {\n      column: column,\n      onResize: onResize,\n      children: cell\n    });\n  }\n\n  return cell;\n}\n\nfunction getColumnScrollPosition(columns, idx, currentScrollLeft, currentClientWidth) {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n\nfunction onEditorNavigation({\n  key,\n  target\n}) {\n  if (key === 'Tab' && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n    return target.matches('.rdg-editor-container > :only-child, .rdg-editor-container > label:only-child > :only-child');\n  }\n\n  return false;\n}\n\nfunction isKeyPrintable(keycode) {\n  return keycode > 47 && keycode < 58 || keycode === 32 || keycode === 13 || keycode > 64 && keycode < 91 || keycode > 95 && keycode < 112 || keycode > 185 && keycode < 193 || keycode > 218 && keycode < 223;\n}\n\nfunction isCtrlKeyHeldDown(e) {\n  return (e.ctrlKey || e.metaKey) && e.key !== 'Control';\n}\n\nfunction isDefaultCellInput(event) {\n  return isKeyPrintable(event.keyCode) || ['Enter', 'F2', 'Backspace', 'Delete'].includes(event.key);\n}\n\nfunction isSelectedCellEditable({\n  selectedPosition,\n  columns,\n  rows,\n  isGroupRow\n}) {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  return column.editor != null && !column.rowGroup && !isGroupRow(row) && (typeof column.editable === 'function' ? column.editable(row) : column.editable) !== false;\n}\n\nfunction getNextSelectedCellPosition({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  nextPosition\n}) {\n  if (cellNavigationMode !== 'NONE') {\n    const {\n      idx,\n      rowIdx\n    } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === 'LOOP_OVER_ROW') {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === 'LOOP_OVER_ROW') {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\nfunction canExitGrid({\n  cellNavigationMode,\n  columns,\n  rowsCount,\n  selectedPosition: {\n    rowIdx,\n    idx\n  },\n  shiftKey\n}) {\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n\nfunction assertIsValidKeyGetter(keyGetter) {\n  if (typeof keyGetter !== 'function') {\n    throw new Error('Please specify the rowKeyGetter prop to use selection');\n  }\n}\n\nfunction HeaderRow({\n  columns,\n  rows,\n  rowKeyGetter,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumn,\n  sortDirection,\n  onSort\n}) {\n  const handleAllRowsSelectionChange = useCallback(checked => {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set();\n\n    if (checked) {\n      for (const row of rows) {\n        newSelectedRows.add(rowKeyGetter(row));\n      }\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }, [onSelectedRowsChange, rows, rowKeyGetter]);\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": 1,\n    className: \"rdg-header-row\",\n    children: columns.map(column => {\n      return /*#__PURE__*/jsx(HeaderCell, {\n        column: column,\n        onResize: onColumnResize,\n        allRowsSelected: allRowsSelected,\n        onAllRowsSelectionChange: handleAllRowsSelectionChange,\n        onSort: onSort,\n        sortColumn: sortColumn,\n        sortDirection: sortDirection\n      }, column.key);\n    })\n  });\n}\n\nconst HeaderRow$1 = /*#__PURE__*/memo(HeaderRow);\n\nfunction FilterRow({\n  columns,\n  filters,\n  onFiltersChange\n}) {\n  function onChange(key, value) {\n    const newFilters = { ...filters\n    };\n    newFilters[key] = value;\n    onFiltersChange == null ? void 0 : onFiltersChange(newFilters);\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": 2,\n    className: \"rdg-filter-row\",\n    children: columns.map(column => {\n      const {\n        key\n      } = column;\n      const className = clsx('rdg-cell', column.frozen && 'rdg-cell-frozen', column.isLastFrozenColumn && 'rdg-cell-frozen-last');\n      const style = {\n        width: column.width,\n        left: column.left\n      };\n      return /*#__PURE__*/jsx(\"div\", {\n        style: style,\n        className: className,\n        children: column.filterRenderer && /*#__PURE__*/jsx(column.filterRenderer, {\n          column: column,\n          value: filters == null ? void 0 : filters[column.key],\n          onChange: value => onChange(key, value)\n        })\n      }, key);\n    })\n  });\n}\n\nconst FilterRow$1 = /*#__PURE__*/memo(FilterRow);\n\nfunction Cell({\n  className,\n  column,\n  isCellSelected,\n  isCopied,\n  isDraggedOver,\n  isRowSelected,\n  row,\n  rowIdx,\n  dragHandleProps,\n  onRowClick,\n  onClick,\n  onDoubleClick,\n  onContextMenu,\n  onRowChange,\n  selectCell,\n  selectRow,\n  ...props\n}, ref) {\n  const cellRef = useRef(null);\n  const {\n    cellClass\n  } = column;\n  className = clsx('rdg-cell', typeof cellClass === 'function' ? cellClass(row) : cellClass, className, column.frozen && 'rdg-cell-frozen', column.isLastFrozenColumn && 'rdg-cell-frozen-last', isCellSelected && 'rdg-cell-selected', isCopied && 'rdg-cell-copied', isDraggedOver && 'rdg-cell-dragged-over');\n\n  function selectCellWrapper(openEditor) {\n    selectCell({\n      idx: column.idx,\n      rowIdx\n    }, openEditor);\n  }\n\n  function handleClick() {\n    var _column$editorOptions;\n\n    selectCellWrapper((_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.editOnClick);\n    onRowClick == null ? void 0 : onRowClick(rowIdx, row, column);\n  }\n\n  function handleContextMenu() {\n    selectCellWrapper();\n  }\n\n  function handleDoubleClick() {\n    selectCellWrapper(true);\n  }\n\n  function handleRowChange(newRow) {\n    onRowChange(rowIdx, newRow);\n  }\n\n  function onRowSelectionChange(checked, isShiftClick) {\n    selectRow({\n      rowIdx,\n      checked,\n      isShiftClick\n    });\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-selected\": isCellSelected,\n    ref: useCombinedRefs(cellRef, ref),\n    className: className,\n    style: {\n      width: column.width,\n      left: column.left\n    },\n    onClick: wrapEvent(handleClick, onClick),\n    onDoubleClick: wrapEvent(handleDoubleClick, onDoubleClick),\n    onContextMenu: wrapEvent(handleContextMenu, onContextMenu),\n    ...props,\n    children: !column.rowGroup && /*#__PURE__*/jsxs(Fragment, {\n      children: [/*#__PURE__*/jsx(column.formatter, {\n        column: column,\n        rowIdx: rowIdx,\n        row: row,\n        isCellSelected: isCellSelected,\n        isRowSelected: isRowSelected,\n        onRowSelectionChange: onRowSelectionChange,\n        onRowChange: handleRowChange\n      }), dragHandleProps && /*#__PURE__*/jsx(\"div\", {\n        className: \"rdg-cell-drag-handle\",\n        ...dragHandleProps\n      })]\n    })\n  });\n}\n\nconst Cell$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(Cell));\n\nfunction EditorContainer({\n  row,\n  column,\n  onRowChange,\n  ...props\n}) {\n  var _column$editorOptions;\n\n  const onClickCapture = useClickOutside(() => onRowChange(row, true));\n  if (column.editor === undefined) return null;\n  const editor = /*#__PURE__*/jsx(\"div\", {\n    className: \"rdg-editor-container\",\n    onClickCapture: onClickCapture,\n    children: /*#__PURE__*/jsx(column.editor, {\n      row: row,\n      column: column,\n      onRowChange: onRowChange,\n      ...props\n    })\n  });\n\n  if ((_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.createPortal) {\n    return /*#__PURE__*/createPortal(editor, props.editorPortalTarget);\n  }\n\n  return editor;\n}\n\nfunction EditCell({\n  className,\n  column,\n  row,\n  rowIdx,\n  editorProps,\n  ...props\n}) {\n  const [dimensions, setDimensions] = useState(null);\n  const cellRef = useCallback(node => {\n    if (node !== null) {\n      const {\n        left,\n        top\n      } = node.getBoundingClientRect();\n      setDimensions({\n        left,\n        top\n      });\n    }\n  }, []);\n  const {\n    cellClass\n  } = column;\n  className = clsx(\"rdg-cell rdg-cell-selected rdg-cell-editing\", typeof cellClass === 'function' ? cellClass(row) : cellClass, className, column.frozen && 'rdg-cell-frozen', column.isLastFrozenColumn && 'rdg-cell-frozen-last');\n\n  function getCellContent() {\n    var _document$scrollingEl;\n\n    if (dimensions === null) return;\n    const {\n      scrollTop: docTop,\n      scrollLeft: docLeft\n    } = (_document$scrollingEl = document.scrollingElement) != null ? _document$scrollingEl : document.documentElement;\n    const {\n      left,\n      top\n    } = dimensions;\n    const gridLeft = left + docLeft;\n    const gridTop = top + docTop;\n    return /*#__PURE__*/jsx(EditorContainer, { ...editorProps,\n      rowIdx: rowIdx,\n      column: column,\n      left: gridLeft,\n      top: gridTop\n    });\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    \"aria-selected\": true,\n    ref: cellRef,\n    className: className,\n    style: {\n      width: column.width,\n      left: column.left\n    },\n    ...props,\n    children: getCellContent()\n  });\n}\n\nfunction Row({\n  cellRenderer: CellRenderer = Cell$1,\n  className,\n  rowIdx,\n  isRowSelected,\n  copiedCellIdx,\n  draggedOverCellIdx,\n  row,\n  viewportColumns,\n  selectedCellProps,\n  onRowClick,\n  rowClass,\n  setDraggedOverRowIdx,\n  onMouseEnter,\n  top,\n  onRowChange,\n  selectCell,\n  selectRow,\n  'aria-rowindex': ariaRowIndex,\n  'aria-selected': ariaSelected,\n  ...props\n}, ref) {\n  function handleDragEnter() {\n    setDraggedOverRowIdx == null ? void 0 : setDraggedOverRowIdx(rowIdx);\n  }\n\n  className = clsx(`rdg-row rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, rowClass == null ? void 0 : rowClass(row), className, isRowSelected && 'rdg-row-selected', (selectedCellProps == null ? void 0 : selectedCellProps.idx) === -1 && 'rdg-group-row-selected');\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": ariaRowIndex,\n    \"aria-selected\": ariaSelected,\n    ref: ref,\n    className: className,\n    onMouseEnter: wrapEvent(handleDragEnter, onMouseEnter),\n    style: {\n      top\n    },\n    ...props,\n    children: viewportColumns.map(column => {\n      const isCellSelected = (selectedCellProps == null ? void 0 : selectedCellProps.idx) === column.idx;\n\n      if ((selectedCellProps == null ? void 0 : selectedCellProps.mode) === 'EDIT' && isCellSelected) {\n        return /*#__PURE__*/jsx(EditCell, {\n          rowIdx: rowIdx,\n          column: column,\n          row: row,\n          onKeyDown: selectedCellProps.onKeyDown,\n          editorProps: selectedCellProps.editorProps\n        }, column.key);\n      }\n\n      return /*#__PURE__*/jsx(CellRenderer, {\n        rowIdx: rowIdx,\n        column: column,\n        row: row,\n        isCopied: copiedCellIdx === column.idx,\n        isDraggedOver: draggedOverCellIdx === column.idx,\n        isCellSelected: isCellSelected,\n        isRowSelected: isRowSelected,\n        dragHandleProps: isCellSelected ? selectedCellProps.dragHandleProps : undefined,\n        onFocus: isCellSelected ? selectedCellProps.onFocus : undefined,\n        onKeyDown: isCellSelected ? selectedCellProps.onKeyDown : undefined,\n        onRowClick: onRowClick,\n        onRowChange: onRowChange,\n        selectCell: selectCell,\n        selectRow: selectRow\n      }, column.key);\n    })\n  });\n}\n\nconst Row$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(Row));\n\nfunction GroupCell({\n  id,\n  rowIdx,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  isRowSelected,\n  column,\n  groupColumnIndex,\n  selectRow,\n  toggleGroup: toggleGroupWrapper\n}) {\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  function onRowSelectionChange(checked) {\n    selectRow({\n      rowIdx,\n      checked,\n      isShiftClick: false\n    });\n  }\n\n  const isLevelMatching = column.rowGroup && groupColumnIndex === column.idx;\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    className: clsx('rdg-cell', column.frozen && 'rdg-cell-frozen', column.isLastFrozenColumn && 'rdg-cell-frozen-last', isCellSelected && 'rdg-cell-selected'),\n    style: {\n      width: column.width,\n      left: column.left,\n      cursor: isLevelMatching ? 'pointer' : 'default'\n    },\n    onClick: isLevelMatching ? toggleGroup : undefined,\n    children: column.groupFormatter && (!column.rowGroup || groupColumnIndex === column.idx) && /*#__PURE__*/jsx(column.groupFormatter, {\n      groupKey: groupKey,\n      childRows: childRows,\n      column: column,\n      isExpanded: isExpanded,\n      isCellSelected: isCellSelected,\n      isRowSelected: isRowSelected,\n      onRowSelectionChange: onRowSelectionChange,\n      toggleGroup: toggleGroup\n    })\n  }, column.key);\n}\n\nconst GroupCell$1 = /*#__PURE__*/memo(GroupCell);\n\nfunction GroupedRow({\n  id,\n  groupKey,\n  viewportColumns,\n  childRows,\n  rowIdx,\n  top,\n  level,\n  isExpanded,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  selectRow,\n  toggleGroup,\n  ...props\n}) {\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? level + 1 : level;\n\n  function selectGroup() {\n    selectCell({\n      rowIdx,\n      idx: -1\n    });\n  }\n\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-level\": level,\n    \"aria-expanded\": isExpanded,\n    className: clsx(`rdg-row rdg-group-row rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, isRowSelected && 'rdg-row-selected', selectedCellIdx === -1 && 'rdg-group-row-selected'),\n    onClick: selectGroup,\n    style: {\n      top\n    },\n    ...props,\n    children: viewportColumns.map(column => /*#__PURE__*/jsx(GroupCell$1, {\n      id: id,\n      rowIdx: rowIdx,\n      groupKey: groupKey,\n      childRows: childRows,\n      isExpanded: isExpanded,\n      isRowSelected: isRowSelected,\n      isCellSelected: selectedCellIdx === column.idx,\n      column: column,\n      groupColumnIndex: idx,\n      selectRow: selectRow,\n      toggleGroup: toggleGroup\n    }, column.key))\n  });\n}\n\nconst GroupRowRenderer = /*#__PURE__*/memo(GroupedRow);\n\nfunction SummaryCell({\n  column,\n  row\n}) {\n  const {\n    summaryFormatter: SummaryFormatter,\n    width,\n    left,\n    summaryCellClass\n  } = column;\n  const className = clsx('rdg-cell', typeof summaryCellClass === 'function' ? summaryCellClass(row) : summaryCellClass, column.frozen && 'rdg-cell-frozen', column.isLastFrozenColumn && 'rdg-cell-frozen-last');\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"gridcell\",\n    \"aria-colindex\": column.idx + 1,\n    className: className,\n    style: {\n      width,\n      left\n    },\n    children: SummaryFormatter && /*#__PURE__*/jsx(SummaryFormatter, {\n      column: column,\n      row: row\n    })\n  });\n}\n\nconst SummaryCell$1 = /*#__PURE__*/memo(SummaryCell);\n\nfunction SummaryRow({\n  rowIdx,\n  row,\n  viewportColumns,\n  bottom,\n  'aria-rowindex': ariaRowIndex\n}) {\n  return /*#__PURE__*/jsx(\"div\", {\n    role: \"row\",\n    \"aria-rowindex\": ariaRowIndex,\n    className: `rdg-row rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'} rdg-summary-row`,\n    style: {\n      bottom\n    },\n    children: viewportColumns.map(column => /*#__PURE__*/jsx(SummaryCell$1, {\n      column: column,\n      row: row\n    }, column.key))\n  });\n}\n\nconst SummaryRow$1 = /*#__PURE__*/memo(SummaryRow);\n\nfunction DataGrid({\n  columns: rawColumns,\n  rows: rawRows,\n  summaryRows,\n  rowKeyGetter,\n  onRowsChange,\n  rowHeight = 35,\n  headerRowHeight = rowHeight,\n  headerFiltersHeight = 45,\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumn,\n  sortDirection,\n  onSort,\n  filters,\n  onFiltersChange,\n  defaultColumnOptions,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  rowRenderer: RowRenderer = Row$1,\n  emptyRowsRenderer: EmptyRowsRenderer,\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onFill,\n  onPaste,\n  enableFilterRow = false,\n  cellNavigationMode = 'NONE',\n  editorPortalTarget = document.body,\n  className,\n  style,\n  rowClass,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  'aria-describedby': ariaDescribedBy\n}, ref) {\n  var _summaryRows$length;\n\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState(() => new Map());\n  const [selectedPosition, setSelectedPosition] = useState({\n    idx: -1,\n    rowIdx: -1,\n    mode: 'SELECT'\n  });\n  const [copiedCell, setCopiedCell] = useState(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState(undefined);\n  const focusSinkRef = useRef(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n  const isCellFocusable = useRef(false);\n  const selectRowWrapper = useLatestFunc(selectRow);\n  const selectCellWrapper = useLatestFunc(selectCell);\n  const toggleGroupWrapper = useLatestFunc(toggleGroup);\n  const handleFormatterRowChangeWrapper = useLatestFunc(handleFormatterRowChange);\n  const [gridRef, gridWidth, gridHeight] = useGridDimensions();\n  const headerRowsCount = enableFilterRow ? 2 : 1;\n  const summaryRowsCount = (_summaryRows$length = summaryRows == null ? void 0 : summaryRows.length) != null ? _summaryRows$length : 0;\n  const totalHeaderHeight = headerRowHeight + (enableFilterRow ? headerFiltersHeight : 0);\n  const clientHeight = gridHeight - totalHeaderHeight - summaryRowsCount * rowHeight;\n  const isSelectable = selectedRows !== undefined && onSelectedRowsChange !== undefined;\n  const {\n    columns,\n    viewportColumns,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  } = useViewportColumns({\n    rawColumns,\n    columnWidths,\n    scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions,\n    rawGroupBy: rowGrouper ? rawGroupBy : undefined\n  });\n  const {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  } = useViewportRows({\n    rawRows,\n    groupBy,\n    rowGrouper,\n    rowHeight,\n    clientHeight,\n    scrollTop,\n    expandedGroupIds\n  });\n  const hasGroups = groupBy.length > 0 && rowGrouper;\n  const minColIdx = hasGroups ? -1 : 0;\n  const enableCellDragAndDrop = hasGroups ? false : onFill !== undefined;\n  useLayoutEffect(() => {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) return;\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n\n    focusSinkRef.current.focus({\n      preventScroll: true\n    });\n  });\n  useImperativeHandle(ref, () => ({\n    scrollToColumn(idx) {\n      scrollToCell({\n        idx\n      });\n    },\n\n    scrollToRow(rowIdx) {\n      const {\n        current\n      } = gridRef;\n      if (!current) return;\n      current.scrollTo({\n        top: rowIdx * rowHeight,\n        behavior: 'smooth'\n      });\n    },\n\n    selectCell\n  }));\n  const handleColumnResize = useCallback((column, width) => {\n    const newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n    onColumnResize == null ? void 0 : onColumnResize(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n  const setDraggedOverRowIdx = useCallback(rowIdx => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  function selectRow({\n    rowIdx,\n    checked,\n    isShiftClick\n  }) {\n    if (!onSelectedRowsChange) return;\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(selectedRows);\n    const row = rows[rowIdx];\n\n    if (isGroupRow(row)) {\n      for (const childRow of row.childRows) {\n        const rowKey = rowKeyGetter(childRow);\n\n        if (checked) {\n          newSelectedRows.add(rowKey);\n        } else {\n          newSelectedRows.delete(rowKey);\n        }\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n      return;\n    }\n\n    const rowKey = rowKeyGetter(row);\n\n    if (checked) {\n      newSelectedRows.add(rowKey);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = Math.sign(rowIdx - previousRowIdx);\n\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          const row = rows[i];\n          if (isGroupRow(row)) continue;\n          newSelectedRows.add(rowKeyGetter(row));\n        }\n      }\n    } else {\n      newSelectedRows.delete(rowKey);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  function toggleGroup(expandedGroupId) {\n    if (!onExpandedGroupIdsChange) return;\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n\n    if (newExpandedGroupIds.has(expandedGroupId)) {\n      newExpandedGroupIds.delete(expandedGroupId);\n    } else {\n      newExpandedGroupIds.add(expandedGroupId);\n    }\n\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function handleKeyDown(event) {\n    const {\n      key,\n      keyCode\n    } = event;\n    const row = rows[selectedPosition.rowIdx];\n\n    if (onPaste && isCtrlKeyHeldDown(event) && isCellWithinBounds(selectedPosition) && !isGroupRow(row) && selectedPosition.idx !== -1 && selectedPosition.mode === 'SELECT') {\n      const cKey = 67;\n      const vKey = 86;\n\n      if (keyCode === cKey) {\n        handleCopy();\n        return;\n      }\n\n      if (keyCode === vKey) {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (isCellWithinBounds(selectedPosition) && isGroupRow(row) && selectedPosition.idx === -1 && (key === 'ArrowLeft' && row.isExpanded || key === 'ArrowRight' && !row.isExpanded)) {\n      event.preventDefault();\n      toggleGroup(row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedCell(null);\n        closeEditor();\n        return;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event) {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll == null ? void 0 : onScroll(event);\n  }\n\n  function getRawRowIdx(rowIdx) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx]) : rowIdx;\n  }\n\n  function commitEditorChanges() {\n    var _columns$selectedPosi;\n\n    if (((_columns$selectedPosi = columns[selectedPosition.idx]) == null ? void 0 : _columns$selectedPosi.editor) === undefined || selectedPosition.mode === 'SELECT' || selectedPosition.row === selectedPosition.originalRow) {\n      return;\n    }\n\n    const updatedRows = [...rawRows];\n    updatedRows[getRawRowIdx(selectedPosition.rowIdx)] = selectedPosition.row;\n    onRowsChange == null ? void 0 : onRowsChange(updatedRows);\n  }\n\n  function handleCopy() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    setCopiedCell({\n      row: rawRows[getRawRowIdx(rowIdx)],\n      columnKey: columns[idx].key\n    });\n  }\n\n  function handlePaste() {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const targetRow = rawRows[getRawRowIdx(rowIdx)];\n\n    if (!onPaste || !onRowsChange || copiedCell === null || !isCellEditable(selectedPosition)) {\n      return;\n    }\n\n    const updatedTargetRow = onPaste({\n      sourceRow: copiedCell.row,\n      sourceColumnKey: copiedCell.columnKey,\n      targetRow,\n      targetColumnKey: columns[idx].key\n    });\n    const updatedRows = [...rawRows];\n    updatedRows[rowIdx] = updatedTargetRow;\n    onRowsChange(updatedRows);\n  }\n\n  function handleCellInput(event) {\n    var _column$editorOptions;\n\n    if (!isCellWithinBounds(selectedPosition)) return;\n    const row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    const {\n      key\n    } = event;\n    const column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        commitEditorChanges();\n        closeEditor();\n      }\n\n      return;\n    }\n\n    (_column$editorOptions = column.editorOptions) == null ? void 0 : _column$editorOptions.onCellKeyDown == null ? void 0 : _column$editorOptions.onCellKeyDown(event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(({\n        idx,\n        rowIdx\n      }) => ({\n        idx,\n        rowIdx,\n        key,\n        mode: 'EDIT',\n        row,\n        originalRow: row\n      }));\n    }\n  }\n\n  function handleDragEnd() {\n    const overRowIdx = latestDraggedOverRowIdx.current;\n    if (overRowIdx === undefined || !onFill || !onRowsChange) return;\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n    const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n    const targetRows = rawRows.slice(startRowIndex, endRowIndex);\n    const updatedTargetRows = onFill({\n      columnKey: columns[idx].key,\n      sourceRow,\n      targetRows\n    });\n    const updatedRows = [...rawRows];\n\n    for (let i = startRowIndex; i < endRowIndex; i++) {\n      updatedRows[i] = updatedTargetRows[i - startRowIndex];\n    }\n\n    onRowsChange(updatedRows);\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event) {\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event) {\n    event.stopPropagation();\n    if (!onFill || !onRowsChange) return;\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const targetRows = rawRows.slice(rowIdx + 1);\n    const updatedTargetRows = onFill({\n      columnKey: columns[idx].key,\n      sourceRow,\n      targetRows\n    });\n    const updatedRows = [...rawRows];\n\n    for (let i = rowIdx + 1; i < updatedRows.length; i++) {\n      updatedRows[i] = updatedTargetRows[i - rowIdx - 1];\n    }\n\n    onRowsChange(updatedRows);\n  }\n\n  function handleFormatterRowChange(rowIdx, row) {\n    const newRows = [...rawRows];\n    newRows[rowIdx] = row;\n    onRowsChange == null ? void 0 : onRowsChange(newRows);\n  }\n\n  function handleEditorRowChange(row, commitChanges) {\n    if (selectedPosition.mode === 'SELECT') return;\n\n    if (commitChanges) {\n      const updatedRows = [...rawRows];\n      updatedRows[getRawRowIdx(selectedPosition.rowIdx)] = row;\n      onRowsChange == null ? void 0 : onRowsChange(updatedRows);\n      closeEditor();\n    } else {\n      setSelectedPosition(position => ({ ...position,\n        row\n      }));\n    }\n  }\n\n  function handleOnClose(commitChanges) {\n    if (commitChanges) {\n      commitEditorChanges();\n    }\n\n    closeEditor();\n  }\n\n  function isCellWithinBounds({\n    idx,\n    rowIdx\n  }) {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position) {\n    return isCellWithinBounds(position) && isSelectedCellEditable({\n      columns,\n      rows,\n      selectedPosition: position,\n      isGroupRow\n    });\n  }\n\n  function selectCell(position, enableEditor = false) {\n    if (!isCellWithinBounds(position)) return;\n    commitEditorChanges();\n\n    if (enableEditor && isCellEditable(position)) {\n      const row = rows[position.rowIdx];\n      setSelectedPosition({ ...position,\n        mode: 'EDIT',\n        key: null,\n        row,\n        originalRow: row\n      });\n    } else {\n      setSelectedPosition({ ...position,\n        mode: 'SELECT'\n      });\n    }\n\n    onSelectedCellChange == null ? void 0 : onSelectedCellChange({ ...position\n    });\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(({\n      idx,\n      rowIdx\n    }) => ({\n      idx,\n      rowIdx,\n      mode: 'SELECT'\n    }));\n  }\n\n  function scrollToCell({\n    idx,\n    rowIdx\n  }) {\n    const {\n      current\n    } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const {\n        clientWidth\n      } = current;\n      const {\n        left,\n        width\n      } = columns[idx];\n      const isCellAtLeftBoundary = left < scrollLeft + width + totalFrozenColumnWidth;\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        const newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key, ctrlKey, shiftKey) {\n    const {\n      idx,\n      rowIdx\n    } = selectedPosition;\n    const row = rows[rowIdx];\n    const isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1;\n\n    if (key === 'ArrowLeft' && isRowSelected && isGroupRow(row) && !row.isExpanded && row.level !== 0) {\n      let parentRowIdx = -1;\n\n      for (let i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n\n      if (parentRowIdx !== -1) {\n        return {\n          idx,\n          rowIdx: parentRowIdx\n        };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return {\n          idx,\n          rowIdx: rowIdx - 1\n        };\n\n      case 'ArrowDown':\n        return {\n          idx,\n          rowIdx: rowIdx + 1\n        };\n\n      case 'ArrowLeft':\n        return {\n          idx: idx - 1,\n          rowIdx\n        };\n\n      case 'ArrowRight':\n        return {\n          idx: idx + 1,\n          rowIdx\n        };\n\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? {\n            idx: columns.length - 1,\n            rowIdx: rows.length - 1\n          } : {\n            idx: 0,\n            rowIdx: 0\n          };\n        }\n\n        return {\n          idx: idx + (shiftKey ? -1 : 1),\n          rowIdx\n        };\n\n      case 'Home':\n        if (isRowSelected) return {\n          idx,\n          rowIdx: 0\n        };\n        return ctrlKey ? {\n          idx: 0,\n          rowIdx: 0\n        } : {\n          idx: 0,\n          rowIdx\n        };\n\n      case 'End':\n        if (isRowSelected) return {\n          idx,\n          rowIdx: rows.length - 1\n        };\n        return ctrlKey ? {\n          idx: columns.length - 1,\n          rowIdx: rows.length - 1\n        } : {\n          idx: columns.length - 1,\n          rowIdx\n        };\n\n      case 'PageUp':\n        return {\n          idx,\n          rowIdx: rowIdx - Math.floor(clientHeight / rowHeight)\n        };\n\n      case 'PageDown':\n        return {\n          idx,\n          rowIdx: rowIdx + Math.floor(clientHeight / rowHeight)\n        };\n\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event) {\n    if (selectedPosition.mode === 'EDIT') {\n      var _columns$selectedPosi2, _columns$selectedPosi3;\n\n      const onNavigation = (_columns$selectedPosi2 = (_columns$selectedPosi3 = columns[selectedPosition.idx].editorOptions) == null ? void 0 : _columns$selectedPosi3.onNavigation) != null ? _columns$selectedPosi2 : onEditorNavigation;\n      if (!onNavigation(event)) return;\n    }\n\n    const {\n      key,\n      shiftKey\n    } = event;\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    let nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n    let mode = cellNavigationMode;\n\n    if (key === 'Tab') {\n      if (canExitGrid({\n        shiftKey,\n        cellNavigationMode,\n        columns,\n        rowsCount: rows.length,\n        selectedPosition\n      })) {\n        commitEditorChanges();\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE' ? 'CHANGE_ROW' : cellNavigationMode;\n    }\n\n    event.preventDefault();\n    nextPosition = getNextSelectedCellPosition({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx) {\n    if (draggedOverRowIdx === undefined) return;\n    const {\n      rowIdx\n    } = selectedPosition;\n    const isDraggedOver = rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx) {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorProps: {\n          editorPortalTarget,\n          rowHeight,\n          row: selectedPosition.row,\n          onRowChange: handleEditorRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition) ? {\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick\n      } : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    let startRowIndex = 0;\n\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      const top = rowIdx * rowHeight + totalHeaderHeight;\n\n      if (isGroupRow(row)) {\n        ({\n          startRowIndex\n        } = row);\n        rowElements.push( /*#__PURE__*/jsx(GroupRowRenderer, {\n          \"aria-level\": row.level + 1,\n          \"aria-setsize\": row.setSize,\n          \"aria-posinset\": row.posInSet + 1,\n          \"aria-rowindex\": headerRowsCount + startRowIndex + 1,\n          id: row.id,\n          groupKey: row.groupKey,\n          viewportColumns: viewportColumns,\n          childRows: row.childRows,\n          rowIdx: rowIdx,\n          top: top,\n          level: row.level,\n          isExpanded: row.isExpanded,\n          selectedCellIdx: selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined,\n          isRowSelected: isSelectable && row.childRows.every(cr => selectedRows == null ? void 0 : selectedRows.has(rowKeyGetter(cr))),\n          onFocus: selectedPosition.rowIdx === rowIdx ? handleFocus : undefined,\n          onKeyDown: selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined,\n          selectCell: selectCellWrapper,\n          selectRow: selectRowWrapper,\n          toggleGroup: toggleGroupWrapper\n        }, row.id));\n        continue;\n      }\n\n      startRowIndex++;\n      let key = hasGroups ? startRowIndex : rowIdx;\n      let isRowSelected = false;\n\n      if (typeof rowKeyGetter === 'function') {\n        var _selectedRows$has;\n\n        key = rowKeyGetter(row);\n        isRowSelected = (_selectedRows$has = selectedRows == null ? void 0 : selectedRows.has(key)) != null ? _selectedRows$has : false;\n      }\n\n      rowElements.push( /*#__PURE__*/jsx(RowRenderer, {\n        \"aria-rowindex\": headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1,\n        \"aria-selected\": isSelectable ? isRowSelected : undefined,\n        rowIdx: rowIdx,\n        row: row,\n        viewportColumns: viewportColumns,\n        isRowSelected: isRowSelected,\n        onRowClick: onRowClick,\n        rowClass: rowClass,\n        top: top,\n        copiedCellIdx: copiedCell !== null && copiedCell.row === row ? columns.findIndex(c => c.key === copiedCell.columnKey) : undefined,\n        draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n        setDraggedOverRowIdx: isDragging ? setDraggedOverRowIdx : undefined,\n        selectedCellProps: getSelectedCellProps(rowIdx),\n        onRowChange: handleFormatterRowChangeWrapper,\n        selectCell: selectCellWrapper,\n        selectRow: selectRowWrapper\n      }, key));\n    }\n\n    return rowElements;\n  }\n\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition({\n      idx: -1,\n      rowIdx: -1,\n      mode: 'SELECT'\n    });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (selectedPosition.mode === 'EDIT' && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n    closeEditor();\n  }\n\n  return /*#__PURE__*/jsxs(\"div\", {\n    role: hasGroups ? 'treegrid' : 'grid',\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-multiselectable\": isSelectable ? true : undefined,\n    \"aria-colcount\": columns.length,\n    \"aria-rowcount\": headerRowsCount + rowsCount + summaryRowsCount,\n    className: clsx('rdg', className, isDragging && 'rdg-viewport-dragging'),\n    style: { ...style,\n      '--header-row-height': `${headerRowHeight}px`,\n      '--filter-row-height': `${headerFiltersHeight}px`,\n      '--row-width': `${totalColumnWidth}px`,\n      '--row-height': `${rowHeight}px`\n    },\n    ref: gridRef,\n    onScroll: handleScroll,\n    children: [/*#__PURE__*/jsx(HeaderRow$1, {\n      rowKeyGetter: rowKeyGetter,\n      rows: rawRows,\n      columns: viewportColumns,\n      onColumnResize: handleColumnResize,\n      allRowsSelected: (selectedRows == null ? void 0 : selectedRows.size) === rawRows.length,\n      onSelectedRowsChange: onSelectedRowsChange,\n      sortColumn: sortColumn,\n      sortDirection: sortDirection,\n      onSort: onSort\n    }), enableFilterRow && /*#__PURE__*/jsx(FilterRow$1, {\n      columns: viewportColumns,\n      filters: filters,\n      onFiltersChange: onFiltersChange\n    }), rows.length === 0 && EmptyRowsRenderer ? /*#__PURE__*/jsx(EmptyRowsRenderer, {}) : /*#__PURE__*/jsxs(Fragment, {\n      children: [/*#__PURE__*/jsx(\"div\", {\n        ref: focusSinkRef,\n        tabIndex: 0,\n        className: \"rdg-focus-sink\",\n        onKeyDown: handleKeyDown\n      }), /*#__PURE__*/jsx(\"div\", {\n        style: {\n          height: Math.max(rows.length * rowHeight, clientHeight)\n        }\n      }), getViewportRows(), summaryRows == null ? void 0 : summaryRows.map((row, rowIdx) => /*#__PURE__*/jsx(SummaryRow$1, {\n        \"aria-rowindex\": headerRowsCount + rowsCount + rowIdx + 1,\n        rowIdx: rowIdx,\n        row: row,\n        bottom: rowHeight * (summaryRows.length - 1 - rowIdx),\n        viewportColumns: viewportColumns\n      }, rowIdx))]\n    })]\n  });\n}\n\nconst DataGrid$1 = /*#__PURE__*/forwardRef(DataGrid);\n\nfunction autoFocusAndSelect(input) {\n  input == null ? void 0 : input.focus();\n  input == null ? void 0 : input.select();\n}\n\nfunction TextEditor({\n  row,\n  column,\n  onRowChange,\n  onClose\n}) {\n  return /*#__PURE__*/jsx(\"input\", {\n    className: \"rdg-text-editor\",\n    ref: autoFocusAndSelect,\n    value: row[column.key],\n    onChange: event => onRowChange({ ...row,\n      [column.key]: event.target.value\n    }),\n    onBlur: () => onClose(true)\n  });\n}\n\nexport default DataGrid$1;\nexport { Cell$1 as Cell, Row$1 as Row, SELECT_COLUMN_KEY, SelectCellFormatter, SelectColumn, SortableHeaderCell, TextEditor, ToggleGroupFormatter, ValueFormatter };","map":{"version":3,"sources":["../src/hooks/useCombinedRefs.ts","../src/hooks/useClickOutside.ts","../src/hooks/useGridDimensions.ts","../src/hooks/useFocusRef.ts","../src/formatters/SelectCellFormatter.tsx","../src/formatters/ValueFormatter.tsx","../src/formatters/ToggleGroupFormatter.tsx","../src/utils/domUtils.ts","../src/Columns.tsx","../src/hooks/useViewportColumns.ts","../src/hooks/useViewportRows.ts","../src/hooks/useLatestFunc.ts","../src/headerCells/SortableHeaderCell.tsx","../src/headerCells/ResizableHeaderCell.tsx","../src/HeaderCell.tsx","../src/utils/columnUtils.ts","../src/utils/keyboardUtils.ts","../src/utils/selectedCellUtils.ts","../src/utils/index.ts","../src/HeaderRow.tsx","../src/FilterRow.tsx","../src/Cell.tsx","../src/editors/EditorContainer.tsx","../src/EditCell.tsx","../src/Row.tsx","../src/GroupCell.tsx","../src/GroupRow.tsx","../src/SummaryCell.tsx","../src/SummaryRow.tsx","../src/DataGrid.tsx","../src/editors/TextEditor.tsx"],"names":["useCallback","handle","ref","frameRequestRef","useRef","cancelAnimationFrame","onClickRef","useEffect","cancelAnimationFrameRequest","requestAnimationFrame","window","capture","gridRef","useState","useLayoutEffect","ResizeObserver","resizeObserver","entries","height","setGridWidth","setGridHeight","preventScroll","ariaLabelledBy","inputRef","useFocusRef","onChange","e","disabled","onClick","props","toggleGroup","cellRef","key","d","isExpanded","event","theirHandler","ourHandler","SELECT_COLUMN_KEY","SelectColumn","name","width","maxWidth","resizable","sortable","frozen","headerRenderer","onAllRowsSelectionChange","formatter","onRowSelectionChange","groupFormatter","stopPropagation","rawGroupBy","minColumnWidth","defaultColumnOptions","defaultFormatter","defaultSortable","defaultResizable","groupBy","useMemo","left","totalWidth","allocatedWidths","unassignedColumnsCount","lastFrozenColumnIndex","totalFrozenColumnWidth","columns","metricsColumn","getSpecifiedWidth","clampColumnWidth","column","frozenA","frozenB","aKey","bKey","unallocatedWidth","viewportWidth","unallocatedColumnWidth","Math","calculatedColumns","newColumn","lastFrozenColumn","totalColumnWidth","viewportLeft","scrollLeft","viewportRight","lastColIdx","firstUnfrozenColumnIdx","colVisibleStartIdx","colVisibleEndIdx","colOverscanStartIdx","colOverscanEndIdx","viewportColumns","colIdx","columnWidths","parseInt","minWidth","RENDER_BACTCH_SIZE","expandedGroupIds","rawRows","groupRows","groupRowsCount","groups","Object","rowGrouper","remainingGroupByKeys","childRows","startRowIndex","childRowsCount","allGroupRows","flattenedRows","expandGroup","Array","id","parentId","groupKey","rows","groupRow","setSize","keys","length","level","isGroupRow","row","overscanThreshold","rowVisibleStartIdx","scrollTop","rowVisibleEndIdx","rowOverscanStartIdx","rowOverscanEndIdx","SORT_TEXT","ASC","DESC","NONE","children","sortDirection","sortColumn","sortDescendingFirst","direction","onSort","onResize","currentTarget","right","offset","onMouseMove","handleResize","onMouseUp","touch","identifier","onTouchMove","getTouch","onTouchEnd","x","target","cloneElement","onTouchStart","cell","getCell","className","clsx","style","getAriaSort","i","selectedColumn","scrollRight","keycode","isKeyPrintable","selectedPosition","nextPosition","cellNavigationMode","rowIdx","columnsCount","isAfterLastColumn","idx","isBeforeFirstColumn","isLastRow","rowsCount","isFirstRow","shiftKey","atLastCellInRow","atFirstCellInRow","atLastRow","atFirstRow","handleAllRowsSelectionChange","checked","assertIsValidKeyGetter","newSelectedRows","rowKeyGetter","onSelectedRowsChange","memo","onFiltersChange","newFilters","filters","value","cellClass","isCellSelected","isCopied","isDraggedOver","selectCell","selectCellWrapper","onRowClick","onRowChange","selectRow","isShiftClick","useCombinedRefs","wrapEvent","handleRowChange","dragHandleProps","forwardRef","onClickCapture","useClickOutside","editor","createPortal","node","top","setDimensions","dimensions","docLeft","document","gridLeft","gridTop","getCellContent","cellRenderer","CellRenderer","setDraggedOverRowIdx","isRowSelected","rowClass","selectedCellProps","editorProps","copiedCellIdx","draggedOverCellIdx","toggleGroupWrapper","isLevelMatching","groupColumnIndex","cursor","selectedCellIdx","summaryFormatter","summaryCellClass","SummaryFormatter","ariaRowIndex","bottom","rowHeight","headerRowHeight","headerFiltersHeight","rowRenderer","RowRenderer","emptyRowsRenderer","enableFilterRow","editorPortalTarget","ariaDescribedBy","mode","focusSinkRef","prevSelectedPosition","latestDraggedOverRowIdx","lastSelectedRowIdx","isCellFocusable","selectRowWrapper","useLatestFunc","handleFormatterRowChangeWrapper","useGridDimensions","headerRowsCount","summaryRowsCount","summaryRows","totalHeaderHeight","clientHeight","gridHeight","isSelectable","selectedRows","useViewportColumns","undefined","useViewportRows","hasGroups","minColIdx","enableCellDragAndDrop","onFill","isCellWithinBounds","scrollToCell","useImperativeHandle","scrollToColumn","scrollToRow","current","behavior","handleColumnResize","newColumnWidths","setColumnWidths","onColumnResize","setOverRowIdx","rowKey","previousRowIdx","step","newExpandedGroupIds","onExpandedGroupIdsChange","keyCode","onPaste","isCtrlKeyHeldDown","cKey","vKey","handleCopy","handlePaste","setCopiedCell","closeEditor","navigate","handleCellInput","setScrollTop","setScrollLeft","onScroll","updatedRows","getRawRowIdx","onRowsChange","columnKey","targetRow","copiedCell","isCellEditable","updatedTargetRow","sourceRow","sourceColumnKey","targetColumnKey","commitEditorChanges","isDefaultCellInput","setSelectedPosition","originalRow","overRowIdx","endRowIndex","targetRows","updatedTargetRows","setDragging","handleDragEnd","newRows","position","isSelectedCellEditable","enableEditor","onSelectedCellChange","clientWidth","isCellAtLeftBoundary","isCellAtRightBoundary","newScrollLeft","getColumnScrollPosition","parentRowIdx","parentRow","ctrlKey","onNavigation","getNextPosition","canExitGrid","getNextSelectedCellPosition","draggedOverRowIdx","currentRowIdx","onKeyDown","onClose","handleOnClose","onFocus","onMouseDown","onDoubleClick","handleDoubleClick","rowElements","cr","c","getDraggedOverCellIdx","isDragging","getSelectedCellProps","_jsx","handleKeyDown","getViewportRows","input"],"mappings":"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","sourcesContent":["import { useCallback } from 'react';\n\nexport function useCombinedRefs<T>(...refs: readonly React.Ref<T>[]) {\n  return useCallback(\n    (handle: T | null) => {\n      for (const ref of refs) {\n        if (typeof ref === 'function') {\n          ref(handle);\n        } else if (ref !== null) {\n          // @ts-expect-error: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065\n          ref.current = handle;\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    refs\n  );\n}\n","import { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use synthetic event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the window\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the window click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the window is set using window.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * the document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\nexport function useClickOutside(onClick: () => void) {\n  const frameRequestRef = useRef<number | undefined>();\n\n  function cancelAnimationFrameRequest() {\n    if (typeof frameRequestRef.current === 'number') {\n      cancelAnimationFrame(frameRequestRef.current);\n      frameRequestRef.current = undefined;\n    }\n  }\n\n  // We need to prevent the `useEffect` from cleaning up between re-renders,\n  // as `handleDocumentClick` might otherwise miss valid click events.\n  // To that end we instead access the latest `onClick` prop via a ref.\n  const onClickRef = useRef((): void => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    onClickRef.current = onClick;\n  });\n\n  useEffect(() => {\n    function onOutsideClick() {\n      frameRequestRef.current = undefined;\n      onClickRef.current();\n    }\n\n    function onWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      frameRequestRef.current = requestAnimationFrame(onOutsideClick);\n    }\n\n    window.addEventListener('click', onWindowCaptureClick, { capture: true });\n\n    return () => {\n      window.removeEventListener('click', onWindowCaptureClick, { capture: true });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n\n  return cancelAnimationFrameRequest;\n}\n","import { useRef, useState, useLayoutEffect } from 'react';\n\n// https://github.com/microsoft/TypeScript/issues/37861\ninterface ResizeObserverEntry {\n  contentRect: {\n    width: number;\n    height: number;\n  };\n}\n\ntype ResizeObserver = new (callback: (entries: readonly ResizeObserverEntry[]) => void) => {\n  observe: (target: Element) => void;\n  disconnect: () => void;\n};\n\nexport function useGridDimensions(): [React.RefObject<HTMLDivElement>, number, number] {\n  const gridRef = useRef<HTMLDivElement>(null);\n  const [gridWidth, setGridWidth] = useState(1);\n  const [gridHeight, setGridHeight] = useState(1);\n\n  useLayoutEffect(() => {\n    const { ResizeObserver } = window as typeof window & { ResizeObserver: ResizeObserver };\n\n    // don't break in jest/jsdom and browsers that don't support ResizeObserver\n    if (ResizeObserver == null) return;\n\n    const resizeObserver = new ResizeObserver(entries => {\n      const { width, height } = entries[0].contentRect;\n      setGridWidth(width);\n      setGridHeight(height);\n    });\n\n    resizeObserver.observe(gridRef.current!);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  return [gridRef, gridWidth, gridHeight];\n}\n","import { useRef, useLayoutEffect } from 'react';\n\nexport function useFocusRef<T extends HTMLOrSVGElement>(isCellSelected: boolean | undefined) {\n  const ref = useRef<T>(null);\n  useLayoutEffect(() => {\n    if (!isCellSelected) return;\n    ref.current?.focus({ preventScroll: true });\n  }, [isCellSelected]);\n\n  return ref;\n}\n","import clsx from 'clsx';\n\nimport { useFocusRef } from '../hooks/useFocusRef';\n\ntype SharedInputProps = Pick<React.InputHTMLAttributes<HTMLInputElement>,\n  | 'disabled'\n  | 'tabIndex'\n  | 'onClick'\n  | 'aria-label'\n  | 'aria-labelledby'\n>;\n\ninterface SelectCellFormatterProps extends SharedInputProps {\n  isCellSelected?: boolean;\n  value: boolean;\n  onChange: (value: boolean, isShiftClick: boolean) => void;\n}\n\nexport function SelectCellFormatter({\n  value,\n  tabIndex,\n  isCellSelected,\n  disabled,\n  onClick,\n  onChange,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy\n}: SelectCellFormatterProps) {\n  const inputRef = useFocusRef<HTMLInputElement>(isCellSelected);\n\n  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {\n    onChange(e.target.checked, (e.nativeEvent as MouseEvent).shiftKey);\n  }\n\n  return (\n    <label className={clsx('rdg-checkbox-label', { 'rdg-checkbox-label-disabled': disabled })}>\n      <input\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        tabIndex={tabIndex}\n        ref={inputRef}\n        type=\"checkbox\"\n        className=\"rdg-checkbox-input\"\n        disabled={disabled}\n        checked={value}\n        onChange={handleChange}\n        onClick={onClick}\n      />\n      <div className=\"rdg-checkbox\" />\n    </label>\n  );\n}\n","import type { FormatterProps } from '../types';\n\nexport function ValueFormatter<R, SR>(props: FormatterProps<R, SR>) {\n  try {\n    return <>{props.row[props.column.key as keyof R]}</>;\n  } catch {\n    return null;\n  }\n}\n","import type { GroupFormatterProps } from '../types';\nimport { useFocusRef } from '../hooks/useFocusRef';\n\nexport function ToggleGroupFormatter<R, SR>({\n  groupKey,\n  isExpanded,\n  isCellSelected,\n  toggleGroup\n}: GroupFormatterProps<R, SR>) {\n  const cellRef = useFocusRef<HTMLSpanElement>(isCellSelected);\n\n  function handleKeyDown({ key }: React.KeyboardEvent<HTMLSpanElement>) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n\n  return (\n    <span\n      ref={cellRef}\n      className=\"rdg-group-cell-content\"\n      tabIndex={-1}\n      onKeyDown={handleKeyDown}\n    >\n      {groupKey}\n      <svg viewBox=\"0 0 14 8\" width=\"14\" height=\"8\" className=\"rdg-caret\">\n        <path d={d} />\n      </svg>\n    </span>\n  );\n}\n","export function preventDefault(event: React.SyntheticEvent) {\n  event.preventDefault();\n}\n\nexport function stopPropagation(event: React.SyntheticEvent) {\n  event.stopPropagation();\n}\n\nexport function wrapEvent<E extends React.SyntheticEvent>(ourHandler: React.EventHandler<E>, theirHandler: React.EventHandler<E> | undefined) {\n  if (theirHandler === undefined) return ourHandler;\n\n  return function(event: E) {\n    ourHandler(event);\n    theirHandler(event);\n  };\n}\n","import { SelectCellFormatter } from './formatters';\nimport type { Column } from './types';\nimport { stopPropagation } from './utils/domUtils';\n\nexport const SELECT_COLUMN_KEY = 'select-row';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const SelectColumn: Column<any, any> = {\n  key: SELECT_COLUMN_KEY,\n  name: '',\n  width: 35,\n  maxWidth: 35,\n  resizable: false,\n  sortable: false,\n  frozen: true,\n  headerRenderer(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select All\"\n        value={props.allRowsSelected}\n        onChange={props.onAllRowsSelectionChange}\n      />\n    );\n  },\n  formatter(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select\"\n        tabIndex={-1}\n        isCellSelected={props.isCellSelected}\n        value={props.isRowSelected}\n        onClick={stopPropagation}\n        onChange={props.onRowSelectionChange}\n      />\n    );\n  },\n  groupFormatter(props) {\n    return (\n      <SelectCellFormatter\n        aria-label=\"Select Group\"\n        tabIndex={-1}\n        isCellSelected={props.isCellSelected}\n        value={props.isRowSelected}\n        onChange={props.onRowSelectionChange}\n        // Stop propagation to prevent row selection\n        onClick={stopPropagation}\n      />\n    );\n  }\n};\n","import { useMemo } from 'react';\n\nimport type { CalculatedColumn, Column } from '../types';\nimport type { DataGridProps } from '../DataGrid';\nimport { ValueFormatter, ToggleGroupFormatter } from '../formatters';\nimport { SELECT_COLUMN_KEY } from '../Columns';\n\ninterface ViewportColumnsArgs<R, SR> extends Pick<DataGridProps<R, SR>, 'defaultColumnOptions'> {\n  rawColumns: readonly Column<R, SR>[];\n  rawGroupBy?: readonly string[];\n  viewportWidth: number;\n  scrollLeft: number;\n  columnWidths: ReadonlyMap<string, number>;\n}\n\nexport function useViewportColumns<R, SR>({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy\n}: ViewportColumnsArgs<R, SR>) {\n  const minColumnWidth = defaultColumnOptions?.minWidth ?? 80;\n  const defaultFormatter = defaultColumnOptions?.formatter ?? ValueFormatter;\n  const defaultSortable = defaultColumnOptions?.sortable ?? false;\n  const defaultResizable = defaultColumnOptions?.resizable ?? false;\n\n  const { columns, lastFrozenColumnIndex, totalColumnWidth, totalFrozenColumnWidth, groupBy } = useMemo(() => {\n    let left = 0;\n    let totalWidth = 0;\n    let allocatedWidths = 0;\n    let unassignedColumnsCount = 0;\n    let lastFrozenColumnIndex = -1;\n    type IntermediateColumn = Column<R, SR> & { width: number | undefined; rowGroup?: boolean };\n    let totalFrozenColumnWidth = 0;\n\n    const columns = rawColumns.map(metricsColumn => {\n      let width = getSpecifiedWidth(metricsColumn, columnWidths, viewportWidth);\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        width = clampColumnWidth(width, metricsColumn, minColumnWidth);\n        allocatedWidths += width;\n      }\n\n      const column: IntermediateColumn = { ...metricsColumn, width };\n\n      if (rawGroupBy?.includes(column.key)) {\n        column.frozen = true;\n        column.rowGroup = true;\n      }\n\n      if (column.frozen) {\n        lastFrozenColumnIndex++;\n      }\n\n      return column;\n    });\n\n    columns.sort(({ key: aKey, frozen: frozenA }, { key: bKey, frozen: frozenB }) => {\n      // Sort select column first:\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      // Sort grouped columns second, following the groupBy order:\n      if (rawGroupBy?.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n        return -1;\n      }\n      if (rawGroupBy?.includes(bKey)) return 1;\n\n      // Sort frozen columns third:\n      if (frozenA) {\n        if (frozenB) return 0;\n        return -1;\n      }\n      if (frozenB) return 1;\n\n      // Sort other columns last:\n      return 0;\n    });\n\n    const unallocatedWidth = viewportWidth - allocatedWidths;\n    const unallocatedColumnWidth = Math.max(\n      Math.floor(unallocatedWidth / unassignedColumnsCount),\n      minColumnWidth\n    );\n\n    // Filter rawGroupBy and ignore keys that do not match the columns prop\n    const groupBy: string[] = [];\n    const calculatedColumns: CalculatedColumn<R, SR>[] = columns.map((column, idx) => {\n      // Every column should have a valid width as this stage\n      const width = column.width ?? clampColumnWidth(unallocatedColumnWidth, column, minColumnWidth);\n      const newColumn = {\n        ...column,\n        idx,\n        width,\n        left,\n        sortable: column.sortable ?? defaultSortable,\n        resizable: column.resizable ?? defaultResizable,\n        formatter: column.formatter ?? defaultFormatter\n      };\n\n      if (newColumn.rowGroup) {\n        groupBy.push(column.key);\n        newColumn.groupFormatter = column.groupFormatter ?? ToggleGroupFormatter;\n      }\n\n      totalWidth += width;\n      left += width;\n      return newColumn;\n    });\n\n    if (lastFrozenColumnIndex !== -1) {\n      const lastFrozenColumn = calculatedColumns[lastFrozenColumnIndex];\n      lastFrozenColumn.isLastFrozenColumn = true;\n      totalFrozenColumnWidth = lastFrozenColumn.left + lastFrozenColumn.width;\n    }\n\n    return {\n      columns: calculatedColumns,\n      lastFrozenColumnIndex,\n      totalFrozenColumnWidth,\n      totalColumnWidth: totalWidth,\n      groupBy\n    };\n  }, [columnWidths, defaultFormatter, defaultResizable, defaultSortable, minColumnWidth, rawColumns, rawGroupBy, viewportWidth]);\n\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo((): [number, number] => {\n    // get the viewport's left side and right side positions for non-frozen columns\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth;\n    // get first and last non-frozen column indexes\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n    // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    }\n\n    // get the first visible non-frozen column index\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n    while (colVisibleStartIdx < lastColIdx) {\n      const { left, width } = columns[colVisibleStartIdx];\n      // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n      if (left + width > viewportLeft) {\n        break;\n      }\n      colVisibleStartIdx++;\n    }\n\n    // get the last visible non-frozen column index\n    let colVisibleEndIdx = colVisibleStartIdx;\n    while (colVisibleEndIdx < lastColIdx) {\n      const { left, width } = columns[colVisibleEndIdx];\n      // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n      if (left + width >= viewportRight) {\n        break;\n      }\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n\n  const viewportColumns = useMemo((): readonly CalculatedColumn<R, SR>[] => {\n    const viewportColumns: CalculatedColumn<R, SR>[] = [];\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n\n  return { columns, viewportColumns, totalColumnWidth, lastFrozenColumnIndex, totalFrozenColumnWidth, groupBy };\n}\n\nfunction getSpecifiedWidth<R, SR>(\n  { key, width }: Column<R, SR>,\n  columnWidths: ReadonlyMap<string, number>,\n  viewportWidth: number\n): number | undefined {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n  if (typeof width === 'number') {\n    return width;\n  }\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n  return undefined;\n}\n\nfunction clampColumnWidth<R, SR>(\n  width: number,\n  { minWidth, maxWidth }: Column<R, SR>,\n  minColumnWidth: number\n): number {\n  width = Math.max(width, minWidth ?? minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n}\n","import { useMemo } from 'react';\n\nimport type { GroupRow, GroupByDictionary, Dictionary } from '../types';\nconst RENDER_BACTCH_SIZE = 8;\n\ninterface ViewportRowsArgs<R> {\n  rawRows: readonly R[];\n  rowHeight: number;\n  clientHeight: number;\n  scrollTop: number;\n  groupBy: readonly string[];\n  rowGrouper?: (rows: readonly R[], columnKey: string) => Dictionary<readonly R[]>;\n  expandedGroupIds?: ReadonlySet<unknown>;\n}\n\nexport function useViewportRows<R>({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}: ViewportRowsArgs<R>) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows: readonly R[], [groupByKey, ...remainingGroupByKeys]: readonly string[], startRowIndex: number): [GroupByDictionary<R>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0\n          ? [childRows, childRows.length]\n          : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, allGroupRows];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n    const expandGroup = (rows: GroupByDictionary<R> | readonly R[], parentId: string | undefined, level: number): void => {\n      if (Array.isArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        // TODO: should users have control over the generated key?\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = expandedGroupIds?.has(id) ?? false;\n        const { childRows, childGroups, startRowIndex } = (rows as GroupByDictionary<R>)[groupKey]; // TODO (ts4.1): https://github.com/microsoft/TypeScript/issues/17002\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = <R>(row: unknown): row is GroupRow<R> => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}\n","import { useRef, useEffect, useCallback } from 'react';\n\n// https://reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useLatestFunc<T extends (...args: any[]) => any>(fn: T) {\n  const ref = useRef(fn);\n\n  useEffect(() => {\n    ref.current = fn;\n  });\n\n  return useCallback((...args: Parameters<T>) => {\n    ref.current(...args);\n  }, []);\n}\n","import type { HeaderCellProps } from '../HeaderCell';\nimport type { SortDirection } from '../enums';\n\nconst SORT_TEXT = {\n  ASC: '\\u25B2',\n  DESC: '\\u25BC',\n  NONE: ''\n} as const;\n\ntype SharedHeaderCellProps<R, SR> = Pick<HeaderCellProps<R, SR>,\n  | 'column'\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n>;\n\nexport interface Props<R, SR> extends SharedHeaderCellProps<R, SR> {\n  children: React.ReactNode;\n}\n\nexport default function SortableHeaderCell<R, SR>({\n  column,\n  onSort,\n  sortColumn,\n  sortDirection,\n  children\n}: Props<R, SR>) {\n  sortDirection = sortColumn === column.key && sortDirection || 'NONE';\n  function onClick() {\n    if (!onSort) return;\n    const { sortDescendingFirst } = column;\n    let direction: SortDirection;\n    switch (sortDirection) {\n      case 'ASC':\n        direction = sortDescendingFirst ? 'NONE' : 'DESC';\n        break;\n      case 'DESC':\n        direction = sortDescendingFirst ? 'ASC' : 'NONE';\n        break;\n      default:\n        direction = sortDescendingFirst ? 'DESC' : 'ASC';\n        break;\n    }\n    onSort(column.key, direction);\n  }\n\n  return (\n    <span className=\"rdg-header-sort-cell\" onClick={onClick}>\n      <span className=\"rdg-header-sort-name\">{children}</span>\n      <span>{SORT_TEXT[sortDirection]}</span>\n    </span>\n  );\n}\n","import { cloneElement } from 'react';\nimport type { CalculatedColumn } from '../types';\n\ninterface ResizableHeaderCellProps<R, SR> {\n  children: React.ReactElement<React.ComponentProps<'div'>>;\n  column: CalculatedColumn<R, SR>;\n  onResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n}\n\nexport default function ResizableHeaderCell<R, SR>({\n  children,\n  column,\n  onResize\n}: ResizableHeaderCellProps<R, SR>) {\n  function onMouseDown(event: React.MouseEvent) {\n    if (event.button !== 0) {\n      return;\n    }\n\n    const { currentTarget } = event;\n    const { right } = currentTarget.getBoundingClientRect();\n    const offset = right - event.clientX;\n\n    if (offset > 11) { // +1px to account for the border size\n      return;\n    }\n\n    const onMouseMove = (event: MouseEvent) => {\n      handleResize(event.clientX + offset, currentTarget);\n    };\n\n    const onMouseUp = () => {\n      window.removeEventListener('mousemove', onMouseMove);\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    event.preventDefault();\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n  }\n\n  function onTouchStart(event: React.TouchEvent) {\n    const touch = event.changedTouches[0];\n    const { identifier } = touch;\n    const { currentTarget } = event;\n    const { right } = currentTarget.getBoundingClientRect();\n    const offset = right - touch.clientX;\n\n    if (offset > 11) { // +1px to account for the border size\n      return;\n    }\n\n    function getTouch(event: TouchEvent) {\n      for (const touch of event.changedTouches) {\n        if (touch.identifier === identifier) return touch;\n      }\n      return null;\n    }\n\n    const onTouchMove = (event: TouchEvent) => {\n      const touch = getTouch(event);\n      if (touch) {\n        handleResize(touch.clientX + offset, currentTarget);\n      }\n    };\n\n    const onTouchEnd = (event: TouchEvent) => {\n      const touch = getTouch(event);\n      if (!touch) return;\n      window.removeEventListener('touchmove', onTouchMove);\n      window.removeEventListener('touchend', onTouchEnd);\n    };\n\n    window.addEventListener('touchmove', onTouchMove);\n    window.addEventListener('touchend', onTouchEnd);\n  }\n\n  function handleResize(x: number, target: Element) {\n    const width = x - target.getBoundingClientRect().left;\n    if (width > 0) {\n      onResize(column, width);\n    }\n  }\n\n  return cloneElement(children, {\n    onMouseDown,\n    onTouchStart\n  });\n}\n","import clsx from 'clsx';\n\nimport type { CalculatedColumn } from './types';\nimport type { HeaderRowProps } from './HeaderRow';\nimport SortableHeaderCell from './headerCells/SortableHeaderCell';\nimport ResizableHeaderCell from './headerCells/ResizableHeaderCell';\nimport type { SortDirection } from './enums';\n\nfunction getAriaSort(sortDirection?: SortDirection) {\n  switch (sortDirection) {\n    case 'ASC':\n      return 'ascending';\n    case 'DESC':\n      return 'descending';\n    default:\n      return 'none';\n  }\n}\n\ntype SharedHeaderRowProps<R, SR> = Pick<HeaderRowProps<R, SR>,\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n  | 'allRowsSelected'\n>;\n\nexport interface HeaderCellProps<R, SR> extends SharedHeaderRowProps<R, SR> {\n  column: CalculatedColumn<R, SR>;\n  onResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n  onAllRowsSelectionChange: (checked: boolean) => void;\n}\n\nexport default function HeaderCell<R, SR>({\n  column,\n  onResize,\n  allRowsSelected,\n  onAllRowsSelectionChange,\n  sortColumn,\n  sortDirection,\n  onSort\n}: HeaderCellProps<R, SR>) {\n  function getCell() {\n    if (column.headerRenderer) {\n      return (\n        <column.headerRenderer\n          column={column}\n          sortColumn={sortColumn}\n          sortDirection={sortDirection}\n          onSort={onSort}\n          allRowsSelected={allRowsSelected}\n          onAllRowsSelectionChange={onAllRowsSelectionChange}\n        />\n      );\n    }\n\n    if (column.sortable) {\n      return (\n        <SortableHeaderCell\n          column={column}\n          onSort={onSort}\n          sortColumn={sortColumn}\n          sortDirection={sortDirection}\n        >\n          {column.name}\n        </SortableHeaderCell>\n      );\n    }\n\n    return column.name;\n  }\n\n  let cell = getCell();\n\n  const className = clsx('rdg-cell', column.headerCellClass, {\n    'rdg-cell-resizable': column.resizable,\n    'rdg-cell-frozen': column.frozen,\n    'rdg-cell-frozen-last': column.isLastFrozenColumn\n  });\n  const style: React.CSSProperties = {\n    width: column.width,\n    left: column.left\n  };\n\n  cell = (\n    <div\n      role=\"columnheader\"\n      aria-colindex={column.idx + 1}\n      aria-sort={sortColumn === column.key ? getAriaSort(sortDirection) : undefined}\n      className={className}\n      style={style}\n    >\n      {cell}\n    </div>\n  );\n\n  if (column.resizable) {\n    cell = (\n      <ResizableHeaderCell\n        column={column}\n        onResize={onResize}\n      >\n        {cell as React.ReactElement<React.ComponentProps<'div'>>}\n      </ResizableHeaderCell>\n    );\n  }\n\n  return cell;\n}\n","import type { CalculatedColumn } from '../types';\n\nexport function getColumnScrollPosition<R, SR>(columns: readonly CalculatedColumn<R, SR>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * By default, the following navigation keys are enabled while an editor is open, under specific conditions:\n * - Tab:\n *   - The editor must be an <input>, a <textarea>, or a <select> element.\n *   - The editor element must be the only immediate child of the editor container/a label.\n */\nexport function onEditorNavigation({ key, target }: React.KeyboardEvent<HTMLDivElement>): boolean {\n  if (key === 'Tab' && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) {\n    return target.matches('.rdg-editor-container > :only-child, .rdg-editor-container > label:only-child > :only-child');\n  }\n  return false;\n}\n","export function isKeyPrintable(keycode: number): boolean {\n  return (keycode > 47 && keycode < 58) // number keys\n    || keycode === 32 || keycode === 13 // spacebar & return key(s) (if you want to allow carriage returns)\n    || (keycode > 64 && keycode < 91) // letter keys\n    || (keycode > 95 && keycode < 112) // numpad keys\n    || (keycode > 185 && keycode < 193) // ;=,-./` (in order)\n    || (keycode > 218 && keycode < 223); // [\\]' (in order)\n}\n\nexport function isCtrlKeyHeldDown(e: React.KeyboardEvent): boolean {\n  return (e.ctrlKey || e.metaKey) && e.key !== 'Control';\n}\n\nexport function isDefaultCellInput(event: React.KeyboardEvent<HTMLDivElement>) {\n  return isKeyPrintable(event.keyCode) || ['Enter', 'F2', 'Backspace', 'Delete'].includes(event.key);\n}\n","import type { CellNavigationMode } from '../enums';\nimport type { CalculatedColumn, Position, GroupRow } from '../types';\n\ninterface IsSelectedCellEditableOpts<R, SR> {\n  selectedPosition: Position;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rows: readonly (R | GroupRow<R>)[];\n  isGroupRow: (row: R | GroupRow<R>) => row is GroupRow<R>;\n}\n\nexport function isSelectedCellEditable<R, SR>({ selectedPosition, columns, rows, isGroupRow }: IsSelectedCellEditableOpts<R, SR>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rows[selectedPosition.rowIdx];\n  return column.editor != null\n    && !column.rowGroup\n    && !isGroupRow(row)\n    && (typeof column.editable === 'function' ? column.editable(row) : column.editable) !== false;\n}\n\ninterface GetNextSelectedCellPositionOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport function getNextSelectedCellPosition<R, SR>({ cellNavigationMode, columns, rowsCount, nextPosition }: GetNextSelectedCellPositionOpts<R, SR>): Position {\n  if (cellNavigationMode !== 'NONE') {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1\n          };\n        }\n      } else if (cellNavigationMode === 'LOOP_OVER_ROW') {\n        return {\n          rowIdx,\n          idx: 0\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === 'CHANGE_ROW') {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1\n          };\n        }\n      } else if (cellNavigationMode === 'LOOP_OVER_ROW') {\n        return {\n          rowIdx,\n          idx: columnsCount - 1\n        };\n      }\n    }\n  }\n\n  return nextPosition;\n}\n\ninterface CanExitGridOpts<R, SR> {\n  cellNavigationMode: CellNavigationMode;\n  columns: readonly CalculatedColumn<R, SR>[];\n  rowsCount: number;\n  selectedPosition: Position;\n  shiftKey: boolean;\n}\n\nexport function canExitGrid<R, SR>({ cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx }, shiftKey }: CanExitGridOpts<R, SR>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === 'NONE' || cellNavigationMode === 'CHANGE_ROW') {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n\n    return shiftKey ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n","export * from './domUtils';\nexport * from './columnUtils';\nexport * from './keyboardUtils';\nexport * from './selectedCellUtils';\n\nexport function assertIsValidKeyGetter<R>(keyGetter: unknown): asserts keyGetter is (row: R) => React.Key {\n  if (typeof keyGetter !== 'function') {\n    throw new Error('Please specify the rowKeyGetter prop to use selection');\n  }\n}\n","import { useCallback, memo } from 'react';\n\nimport HeaderCell from './HeaderCell';\nimport type { CalculatedColumn } from './types';\nimport { assertIsValidKeyGetter } from './utils';\nimport type { DataGridProps } from './DataGrid';\n\ntype SharedDataGridProps<R, SR> = Pick<DataGridProps<R, SR>,\n  | 'rows'\n  | 'onSelectedRowsChange'\n  | 'sortColumn'\n  | 'sortDirection'\n  | 'onSort'\n  | 'rowKeyGetter'\n>;\n\nexport interface HeaderRowProps<R, SR> extends SharedDataGridProps<R, SR> {\n  columns: readonly CalculatedColumn<R, SR>[];\n  allRowsSelected: boolean;\n  onColumnResize: (column: CalculatedColumn<R, SR>, width: number) => void;\n}\n\nfunction HeaderRow<R, SR>({\n  columns,\n  rows,\n  rowKeyGetter,\n  onSelectedRowsChange,\n  allRowsSelected,\n  onColumnResize,\n  sortColumn,\n  sortDirection,\n  onSort\n}: HeaderRowProps<R, SR>) {\n  const handleAllRowsSelectionChange = useCallback((checked: boolean) => {\n    if (!onSelectedRowsChange) return;\n\n    assertIsValidKeyGetter(rowKeyGetter);\n\n    const newSelectedRows = new Set<React.Key>();\n    if (checked) {\n      for (const row of rows) {\n        newSelectedRows.add(rowKeyGetter(row));\n      }\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }, [onSelectedRowsChange, rows, rowKeyGetter]);\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={1} // aria-rowindex is 1 based\n      className=\"rdg-header-row\"\n    >\n      {columns.map(column => {\n        return (\n          <HeaderCell<R, SR>\n            key={column.key}\n            column={column}\n            onResize={onColumnResize}\n            allRowsSelected={allRowsSelected}\n            onAllRowsSelectionChange={handleAllRowsSelectionChange}\n            onSort={onSort}\n            sortColumn={sortColumn}\n            sortDirection={sortDirection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(HeaderRow) as <R, SR>(props: HeaderRowProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport clsx from 'clsx';\n\nimport type { CalculatedColumn, Filters } from './types';\nimport type { DataGridProps } from './DataGrid';\n\ntype SharedDataGridProps<R, SR> = Pick<DataGridProps<R, SR>,\n  | 'filters'\n  | 'onFiltersChange'\n>;\n\nexport interface FilterRowProps<R, SR> extends SharedDataGridProps<R, SR> {\n  columns: readonly CalculatedColumn<R, SR>[];\n}\n\nfunction FilterRow<R, SR>({\n  columns,\n  filters,\n  onFiltersChange\n}: FilterRowProps<R, SR>) {\n  function onChange(key: string, value: unknown) {\n    const newFilters: Filters = { ...filters };\n    newFilters[key] = value;\n    onFiltersChange?.(newFilters);\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={2}\n      className=\"rdg-filter-row\"\n    >\n      {columns.map(column => {\n        const { key } = column;\n\n        const className = clsx('rdg-cell', {\n          'rdg-cell-frozen': column.frozen,\n          'rdg-cell-frozen-last': column.isLastFrozenColumn\n        });\n        const style: React.CSSProperties = {\n          width: column.width,\n          left: column.left\n        };\n\n        return (\n          <div\n            key={key}\n            style={style}\n            className={className}\n          >\n            {column.filterRenderer && (\n              <column.filterRenderer\n                column={column}\n                value={filters?.[column.key]}\n                onChange={value => onChange(key, value)}\n              />\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(FilterRow) as <R, SR>(props: FilterRowProps<R, SR>) => JSX.Element;\n","import { forwardRef, memo, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport type { CellRendererProps } from './types';\nimport { wrapEvent } from './utils';\nimport { useCombinedRefs } from './hooks';\n\nfunction Cell<R, SR>({\n  className,\n  column,\n  isCellSelected,\n  isCopied,\n  isDraggedOver,\n  isRowSelected,\n  row,\n  rowIdx,\n  dragHandleProps,\n  onRowClick,\n  onClick,\n  onDoubleClick,\n  onContextMenu,\n  onRowChange,\n  selectCell,\n  selectRow,\n  ...props\n}: CellRendererProps<R, SR>, ref: React.Ref<HTMLDivElement>) {\n  const cellRef = useRef<HTMLDivElement>(null);\n\n  const { cellClass } = column;\n  className = clsx(\n    'rdg-cell',\n    {\n      'rdg-cell-frozen': column.frozen,\n      'rdg-cell-frozen-last': column.isLastFrozenColumn,\n      'rdg-cell-selected': isCellSelected,\n      'rdg-cell-copied': isCopied,\n      'rdg-cell-dragged-over': isDraggedOver\n    },\n    typeof cellClass === 'function' ? cellClass(row) : cellClass,\n    className\n  );\n\n  function selectCellWrapper(openEditor?: boolean) {\n    selectCell({ idx: column.idx, rowIdx }, openEditor);\n  }\n\n  function handleClick() {\n    selectCellWrapper(column.editorOptions?.editOnClick);\n    onRowClick?.(rowIdx, row, column);\n  }\n\n  function handleContextMenu() {\n    selectCellWrapper();\n  }\n\n  function handleDoubleClick() {\n    selectCellWrapper(true);\n  }\n\n  function handleRowChange(newRow: R) {\n    onRowChange(rowIdx, newRow);\n  }\n\n  function onRowSelectionChange(checked: boolean, isShiftClick: boolean) {\n    selectRow({ rowIdx, checked, isShiftClick });\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected={isCellSelected}\n      ref={useCombinedRefs(cellRef, ref)}\n      className={className}\n      style={{\n        width: column.width,\n        left: column.left\n      }}\n      onClick={wrapEvent(handleClick, onClick)}\n      onDoubleClick={wrapEvent(handleDoubleClick, onDoubleClick)}\n      onContextMenu={wrapEvent(handleContextMenu, onContextMenu)}\n      {...props}\n    >\n      {!column.rowGroup && (\n        <>\n          <column.formatter\n            column={column}\n            rowIdx={rowIdx}\n            row={row}\n            isCellSelected={isCellSelected}\n            isRowSelected={isRowSelected}\n            onRowSelectionChange={onRowSelectionChange}\n            onRowChange={handleRowChange}\n          />\n          {dragHandleProps && (\n            <div className=\"rdg-cell-drag-handle\" {...dragHandleProps} />\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default memo(forwardRef(Cell)) as <R, SR = unknown>(props: CellRendererProps<R, SR> & React.RefAttributes<HTMLDivElement>) => JSX.Element;\n","import { createPortal } from 'react-dom';\n\nimport type { EditorProps } from '../types';\nimport { useClickOutside } from '../hooks';\n\nexport default function EditorContainer<R, SR>({\n  row,\n  column,\n  onRowChange,\n  ...props\n}: EditorProps<R, SR>) {\n  const onClickCapture = useClickOutside(() => onRowChange(row, true));\n  if (column.editor === undefined) return null;\n\n  const editor = (\n    <div className=\"rdg-editor-container\" onClickCapture={onClickCapture}>\n      <column.editor\n        row={row}\n        column={column}\n        onRowChange={onRowChange}\n        {...props}\n      />\n    </div>\n  );\n\n  if (column.editorOptions?.createPortal) {\n    return createPortal(editor, props.editorPortalTarget);\n  }\n\n  return editor;\n}\n","import { useState, useCallback } from 'react';\nimport clsx from 'clsx';\n\nimport EditorContainer from './editors/EditorContainer';\nimport type { CellRendererProps, SharedEditorProps, Omit } from './types';\n\ntype SharedCellRendererProps<R, SR> = Pick<CellRendererProps<R, SR>,\n  | 'rowIdx'\n  | 'row'\n  | 'column'\n>;\n\ninterface EditCellProps<R, SR> extends SharedCellRendererProps<R, SR>, Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  editorProps: SharedEditorProps<R>;\n}\n\nexport default function EditCell<R, SR>({\n  className,\n  column,\n  row,\n  rowIdx,\n  editorProps,\n  ...props\n}: EditCellProps<R, SR>) {\n  const [dimensions, setDimensions] = useState<{ left: number; top: number } | null>(null);\n\n  const cellRef = useCallback(node => {\n    if (node !== null) {\n      const { left, top } = node.getBoundingClientRect();\n      setDimensions({ left, top });\n    }\n  }, []);\n\n  const { cellClass } = column;\n  className = clsx(\n    'rdg-cell',\n    {\n      'rdg-cell-frozen': column.frozen,\n      'rdg-cell-frozen-last': column.isLastFrozenColumn\n    },\n    'rdg-cell-selected',\n    'rdg-cell-editing',\n    typeof cellClass === 'function' ? cellClass(row) : cellClass,\n    className\n  );\n\n  function getCellContent() {\n    if (dimensions === null) return;\n    const { scrollTop: docTop, scrollLeft: docLeft } = document.scrollingElement ?? document.documentElement;\n    const { left, top } = dimensions;\n    const gridLeft = left + docLeft;\n    const gridTop = top + docTop;\n\n    return (\n      <EditorContainer\n        {...editorProps}\n        rowIdx={rowIdx}\n        column={column}\n        left={gridLeft}\n        top={gridTop}\n      />\n    );\n  }\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1} // aria-colindex is 1-based\n      aria-selected\n      ref={cellRef}\n      className={className}\n      style={{\n        width: column.width,\n        left: column.left\n      }}\n      {...props}\n    >\n      {getCellContent()}\n    </div>\n  );\n}\n","import { memo, forwardRef } from 'react';\nimport clsx from 'clsx';\n\nimport Cell from './Cell';\nimport EditCell from './EditCell';\nimport type { RowRendererProps, SelectedCellProps } from './types';\nimport { wrapEvent } from './utils';\n\nfunction Row<R, SR = unknown>({\n  cellRenderer: CellRenderer = Cell,\n  className,\n  rowIdx,\n  isRowSelected,\n  copiedCellIdx,\n  draggedOverCellIdx,\n  row,\n  viewportColumns,\n  selectedCellProps,\n  onRowClick,\n  rowClass,\n  setDraggedOverRowIdx,\n  onMouseEnter,\n  top,\n  onRowChange,\n  selectCell,\n  selectRow,\n  'aria-rowindex': ariaRowIndex,\n  'aria-selected': ariaSelected,\n  ...props\n}: RowRendererProps<R, SR>, ref: React.Ref<HTMLDivElement>) {\n  function handleDragEnter() {\n    setDraggedOverRowIdx?.(rowIdx);\n  }\n\n  className = clsx(\n    'rdg-row',\n    `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, {\n      'rdg-row-selected': isRowSelected,\n      'rdg-group-row-selected': selectedCellProps?.idx === -1\n    },\n    rowClass?.(row),\n    className\n  );\n\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={ariaRowIndex}\n      aria-selected={ariaSelected}\n      ref={ref}\n      className={className}\n      onMouseEnter={wrapEvent(handleDragEnter, onMouseEnter)}\n      style={{ top }}\n      {...props}\n    >\n      {viewportColumns.map(column => {\n        const isCellSelected = selectedCellProps?.idx === column.idx;\n        if (selectedCellProps?.mode === 'EDIT' && isCellSelected) {\n          return (\n            <EditCell<R, SR>\n              key={column.key}\n              rowIdx={rowIdx}\n              column={column}\n              row={row}\n              onKeyDown={selectedCellProps.onKeyDown}\n              editorProps={selectedCellProps.editorProps}\n            />\n          );\n        }\n\n        return (\n          <CellRenderer\n            key={column.key}\n            rowIdx={rowIdx}\n            column={column}\n            row={row}\n            isCopied={copiedCellIdx === column.idx}\n            isDraggedOver={draggedOverCellIdx === column.idx}\n            isCellSelected={isCellSelected}\n            isRowSelected={isRowSelected}\n            dragHandleProps={isCellSelected ? (selectedCellProps as SelectedCellProps).dragHandleProps : undefined}\n            onFocus={isCellSelected ? (selectedCellProps as SelectedCellProps).onFocus : undefined}\n            onKeyDown={isCellSelected ? selectedCellProps!.onKeyDown : undefined}\n            onRowClick={onRowClick}\n            onRowChange={onRowChange}\n            selectCell={selectCell}\n            selectRow={selectRow}\n          />\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(forwardRef(Row)) as <R, SR = unknown>(props: RowRendererProps<R, SR> & React.RefAttributes<HTMLDivElement>) => JSX.Element;\n","import { memo } from 'react';\nimport clsx from 'clsx';\n\nimport type { CalculatedColumn } from './types';\nimport type { GroupRowRendererProps } from './GroupRow';\n\ntype SharedGroupRowRendererProps<R, SR> = Pick<GroupRowRendererProps<R, SR>,\n  | 'id'\n  | 'rowIdx'\n  | 'groupKey'\n  | 'childRows'\n  | 'isExpanded'\n  | 'isRowSelected'\n  | 'selectRow'\n  | 'toggleGroup'\n>;\n\ninterface GroupCellProps<R, SR> extends SharedGroupRowRendererProps<R, SR> {\n  column: CalculatedColumn<R, SR>;\n  isCellSelected: boolean;\n  groupColumnIndex: number;\n}\n\nfunction GroupCell<R, SR>({\n  id,\n  rowIdx,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  isRowSelected,\n  column,\n  groupColumnIndex,\n  selectRow,\n  toggleGroup: toggleGroupWrapper\n}: GroupCellProps<R, SR>) {\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  function onRowSelectionChange(checked: boolean) {\n    selectRow({ rowIdx, checked, isShiftClick: false });\n  }\n\n  // Only make the cell clickable if the group level matches\n  const isLevelMatching = column.rowGroup && groupColumnIndex === column.idx;\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      key={column.key}\n      className={clsx('rdg-cell', {\n        'rdg-cell-frozen': column.frozen,\n        'rdg-cell-frozen-last': column.isLastFrozenColumn,\n        'rdg-cell-selected': isCellSelected\n      })}\n      style={{\n        width: column.width,\n        left: column.left,\n        cursor: isLevelMatching ? 'pointer' : 'default'\n      }}\n      onClick={isLevelMatching ? toggleGroup : undefined}\n    >\n      {column.groupFormatter && (!column.rowGroup || groupColumnIndex === column.idx) && (\n        <column.groupFormatter\n          groupKey={groupKey}\n          childRows={childRows}\n          column={column}\n          isExpanded={isExpanded}\n          isCellSelected={isCellSelected}\n          isRowSelected={isRowSelected}\n          onRowSelectionChange={onRowSelectionChange}\n          toggleGroup={toggleGroup}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default memo(GroupCell) as <R, SR>(props: GroupCellProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport clsx from 'clsx';\n\nimport type { CalculatedColumn, Position, SelectRowEvent, Omit } from './types';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport GroupCell from './GroupCell';\n\nexport interface GroupRowRendererProps<R, SR = unknown> extends Omit<React.HTMLAttributes<HTMLDivElement>, 'style' | 'children'> {\n  id: string;\n  groupKey: unknown;\n  viewportColumns: readonly CalculatedColumn<R, SR>[];\n  childRows: readonly R[];\n  rowIdx: number;\n  top: number;\n  level: number;\n  selectedCellIdx?: number;\n  isExpanded: boolean;\n  isRowSelected: boolean;\n  selectCell: (position: Position, enableEditor?: boolean) => void;\n  selectRow: (selectRowEvent: SelectRowEvent) => void;\n  toggleGroup: (expandedGroupId: unknown) => void;\n}\n\nfunction GroupedRow<R, SR>({\n  id,\n  groupKey,\n  viewportColumns,\n  childRows,\n  rowIdx,\n  top,\n  level,\n  isExpanded,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  selectRow,\n  toggleGroup,\n  ...props\n}: GroupRowRendererProps<R, SR>) {\n  // Select is always the first column\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? level + 1 : level;\n\n  function selectGroup() {\n    selectCell({ rowIdx, idx: -1 });\n  }\n\n  return (\n    <div\n      role=\"row\"\n      aria-level={level}\n      aria-expanded={isExpanded}\n      className={clsx(\n        'rdg-row',\n        'rdg-group-row',\n        `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`, {\n          'rdg-row-selected': isRowSelected,\n          'rdg-group-row-selected': selectedCellIdx === -1 // Select row if there is no selected cell\n        })}\n      onClick={selectGroup}\n      style={{ top }}\n      {...props}\n    >\n      {viewportColumns.map(column => (\n        <GroupCell<R, SR>\n          key={column.key}\n          id={id}\n          rowIdx={rowIdx}\n          groupKey={groupKey}\n          childRows={childRows}\n          isExpanded={isExpanded}\n          isRowSelected={isRowSelected}\n          isCellSelected={selectedCellIdx === column.idx}\n          column={column}\n          groupColumnIndex={idx}\n          selectRow={selectRow}\n          toggleGroup={toggleGroup}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default memo(GroupedRow) as <R, SR>(props: GroupRowRendererProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport clsx from 'clsx';\n\nimport type { CellRendererProps } from './types';\n\ntype SharedCellRendererProps<R, SR> = Pick<CellRendererProps<R, SR>, 'column'>;\n\ninterface SummaryCellProps<R, SR> extends SharedCellRendererProps<R, SR> {\n  row: SR;\n}\n\nfunction SummaryCell<R, SR>({\n  column,\n  row\n}: SummaryCellProps<R, SR>) {\n  const { summaryFormatter: SummaryFormatter, width, left, summaryCellClass } = column;\n  const className = clsx(\n    'rdg-cell',\n    {\n      'rdg-cell-frozen': column.frozen,\n      'rdg-cell-frozen-last': column.isLastFrozenColumn\n    },\n    typeof summaryCellClass === 'function' ? summaryCellClass(row) : summaryCellClass\n  );\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      className={className}\n      style={{ width, left }}\n    >\n      {SummaryFormatter && <SummaryFormatter column={column} row={row} />}\n    </div>\n  );\n}\n\nexport default memo(SummaryCell) as <R, SR>(props: SummaryCellProps<R, SR>) => JSX.Element;\n","import { memo } from 'react';\nimport SummaryCell from './SummaryCell';\nimport type { RowRendererProps } from './types';\n\ntype SharedRowRendererProps<R, SR> = Pick<RowRendererProps<R, SR>,\n  | 'viewportColumns'\n  | 'rowIdx'\n>;\n\ninterface SummaryRowProps<R, SR> extends SharedRowRendererProps<R, SR> {\n  'aria-rowindex': number;\n  row: SR;\n  bottom: number;\n}\n\nfunction SummaryRow<R, SR>({\n  rowIdx,\n  row,\n  viewportColumns,\n  bottom,\n  'aria-rowindex': ariaRowIndex\n}: SummaryRowProps<R, SR>) {\n  return (\n    <div\n      role=\"row\"\n      aria-rowindex={ariaRowIndex}\n      className={`rdg-row rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'} rdg-summary-row`}\n      style={{ bottom }}\n    >\n      {viewportColumns.map(column => (\n        <SummaryCell<R, SR>\n          key={column.key}\n          column={column}\n          row={row}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport default memo(SummaryRow) as <R, SR>(props: SummaryRowProps<R, SR>) => JSX.Element;\n","import {\n  forwardRef,\n  useState,\n  useRef,\n  useLayoutEffect,\n  useImperativeHandle,\n  useCallback\n} from 'react';\nimport clsx from 'clsx';\n\nimport { useGridDimensions, useViewportColumns, useViewportRows, useLatestFunc } from './hooks';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport GroupRowRenderer from './GroupRow';\nimport SummaryRow from './SummaryRow';\nimport {\n  assertIsValidKeyGetter,\n  getColumnScrollPosition,\n  onEditorNavigation,\n  getNextSelectedCellPosition,\n  isSelectedCellEditable,\n  canExitGrid,\n  isCtrlKeyHeldDown,\n  isDefaultCellInput\n} from './utils';\n\nimport type {\n  CalculatedColumn,\n  Column,\n  Filters,\n  Position,\n  RowRendererProps,\n  SelectRowEvent,\n  SelectedCellProps,\n  EditCellProps,\n  Dictionary,\n  FillEvent,\n  PasteEvent\n} from './types';\nimport type { CellNavigationMode, SortDirection } from './enums';\n\ninterface SelectCellState extends Position {\n  mode: 'SELECT';\n}\n\ninterface EditCellState<R> extends Position {\n  mode: 'EDIT';\n  row: R;\n  originalRow: R;\n  key: string | null;\n}\n\ntype DefaultColumnOptions<R, SR> = Pick<Column<R, SR>,\n  | 'formatter'\n  | 'minWidth'\n  | 'resizable'\n  | 'sortable'\n>;\n\nexport interface DataGridHandle {\n  scrollToColumn: (colIdx: number) => void;\n  scrollToRow: (rowIdx: number) => void;\n  selectCell: (position: Position, openEditor?: boolean) => void;\n}\n\ntype SharedDivProps = Pick<React.HTMLAttributes<HTMLDivElement>,\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'aria-describedby'\n  | 'className'\n  | 'style'\n>;\n\nexport interface DataGridProps<R, SR = unknown> extends SharedDivProps {\n  /**\n   * Grid and data Props\n   */\n  /** An array of objects representing each column on the grid */\n  columns: readonly Column<R, SR>[];\n  /** A function called for each rendered row that should return a plain key/value pair object */\n  rows: readonly R[];\n  /**\n   * Rows to be pinned at the bottom of the rows view for summary, the vertical scroll bar will not scroll these rows.\n   * Bottom horizontal scroll bar can move the row left / right. Or a customized row renderer can be used to disabled the scrolling support.\n   */\n  summaryRows?: readonly SR[];\n  /** The getter should return a unique key for each row */\n  rowKeyGetter?: (row: R) => React.Key;\n  onRowsChange?: (rows: R[]) => void;\n\n  /**\n   * Dimensions props\n   */\n  /** The height of each row in pixels */\n  rowHeight?: number;\n  /** The height of the header row in pixels */\n  headerRowHeight?: number;\n  /** The height of the header filter row in pixels */\n  headerFiltersHeight?: number;\n\n  /**\n   * Feature props\n   */\n  /** Set of selected row keys */\n  selectedRows?: ReadonlySet<React.Key>;\n  /** Function called whenever row selection is changed */\n  onSelectedRowsChange?: (selectedRows: Set<React.Key>) => void;\n  /** The key of the column which is currently being sorted */\n  sortColumn?: string;\n  /** The direction to sort the sortColumn*/\n  sortDirection?: SortDirection;\n  /** Function called whenever grid is sorted*/\n  onSort?: (columnKey: string, direction: SortDirection) => void;\n  filters?: Filters;\n  onFiltersChange?: (filters: Filters) => void;\n  defaultColumnOptions?: DefaultColumnOptions<R, SR>;\n  groupBy?: readonly string[];\n  rowGrouper?: (rows: readonly R[], columnKey: string) => Dictionary<readonly R[]>;\n  expandedGroupIds?: ReadonlySet<unknown>;\n  onExpandedGroupIdsChange?: (expandedGroupIds: Set<unknown>) => void;\n  onFill?: (event: FillEvent<R>) => R[];\n  onPaste?: (event: PasteEvent<R>) => R;\n\n  /**\n   * Custom renderers\n   */\n  rowRenderer?: React.ComponentType<RowRendererProps<R, SR>>;\n  emptyRowsRenderer?: React.ComponentType;\n\n  /**\n   * Event props\n   */\n  /** Function called whenever a row is clicked */\n  onRowClick?: (rowIdx: number, row: R, column: CalculatedColumn<R, SR>) => void;\n  /** Called when the grid is scrolled */\n  onScroll?: (event: React.UIEvent<HTMLDivElement>) => void;\n  /** Called when a column is resized */\n  onColumnResize?: (idx: number, width: number) => void;\n  /** Function called whenever selected cell is changed */\n  onSelectedCellChange?: (position: Position) => void;\n\n  /**\n   * Toggles and modes\n   */\n  /** Toggles whether filters row is displayed or not */\n  enableFilterRow?: boolean;\n  cellNavigationMode?: CellNavigationMode;\n\n  /**\n   * Miscellaneous\n   */\n  /** The node where the editor portal should mount. */\n  editorPortalTarget?: Element;\n  rowClass?: (row: R) => string | undefined;\n}\n\n/**\n * Main API Component to render a data grid of rows and columns\n *\n * @example\n *\n * <DataGrid columns={columns} rows={rows} />\n*/\nfunction DataGrid<R, SR>({\n  // Grid and data Props\n  columns: rawColumns,\n  rows: rawRows,\n  summaryRows,\n  rowKeyGetter,\n  onRowsChange,\n  // Dimensions props\n  rowHeight = 35,\n  headerRowHeight = rowHeight,\n  headerFiltersHeight = 45,\n  // Feature props\n  selectedRows,\n  onSelectedRowsChange,\n  sortColumn,\n  sortDirection,\n  onSort,\n  filters,\n  onFiltersChange,\n  defaultColumnOptions,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  // Custom renderers\n  rowRenderer: RowRenderer = Row,\n  emptyRowsRenderer: EmptyRowsRenderer,\n  // Event props\n  onRowClick,\n  onScroll,\n  onColumnResize,\n  onSelectedCellChange,\n  onFill,\n  onPaste,\n  // Toggles and modes\n  enableFilterRow = false,\n  cellNavigationMode = 'NONE',\n  // Miscellaneous\n  editorPortalTarget = document.body,\n  className,\n  style,\n  rowClass,\n  // ARIA\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  'aria-describedby': ariaDescribedBy\n}: DataGridProps<R, SR>, ref: React.Ref<DataGridHandle>) {\n  /**\n   * states\n   */\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const [columnWidths, setColumnWidths] = useState<ReadonlyMap<string, number>>(() => new Map());\n  const [selectedPosition, setSelectedPosition] = useState<SelectCellState | EditCellState<R>>({ idx: -1, rowIdx: -1, mode: 'SELECT' });\n  const [copiedCell, setCopiedCell] = useState<{ row: R; columnKey: string } | null>(null);\n  const [isDragging, setDragging] = useState(false);\n  const [draggedOverRowIdx, setOverRowIdx] = useState<number | undefined>(undefined);\n\n  /**\n   * refs\n   */\n  const focusSinkRef = useRef<HTMLDivElement>(null);\n  const prevSelectedPosition = useRef(selectedPosition);\n  const latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  const lastSelectedRowIdx = useRef(-1);\n  const isCellFocusable = useRef(false);\n\n  /**\n   * The identity of the wrapper function is stable so it won't break memoization\n   */\n  const selectRowWrapper = useLatestFunc(selectRow);\n  const selectCellWrapper = useLatestFunc(selectCell);\n  const toggleGroupWrapper = useLatestFunc(toggleGroup);\n  const handleFormatterRowChangeWrapper = useLatestFunc(handleFormatterRowChange);\n\n  /**\n   * computed values\n   */\n  const [gridRef, gridWidth, gridHeight] = useGridDimensions();\n  const headerRowsCount = enableFilterRow ? 2 : 1;\n  const summaryRowsCount = summaryRows?.length ?? 0;\n  const totalHeaderHeight = headerRowHeight + (enableFilterRow ? headerFiltersHeight : 0);\n  const clientHeight = gridHeight - totalHeaderHeight - summaryRowsCount * rowHeight;\n  const isSelectable = selectedRows !== undefined && onSelectedRowsChange !== undefined;\n\n  const { columns, viewportColumns, totalColumnWidth, lastFrozenColumnIndex, totalFrozenColumnWidth, groupBy } = useViewportColumns({\n    rawColumns,\n    columnWidths,\n    scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions,\n    rawGroupBy: rowGrouper ? rawGroupBy : undefined\n  });\n\n  const { rowOverscanStartIdx, rowOverscanEndIdx, rows, rowsCount, isGroupRow } = useViewportRows({\n    rawRows,\n    groupBy,\n    rowGrouper,\n    rowHeight,\n    clientHeight,\n    scrollTop,\n    expandedGroupIds\n  });\n\n  const hasGroups = groupBy.length > 0 && rowGrouper;\n  const minColIdx = hasGroups ? -1 : 0;\n\n  // Cell drag is not supported on a treegrid\n  const enableCellDragAndDrop = hasGroups ? false : onFill !== undefined;\n\n  /**\n   * effects\n   */\n  useLayoutEffect(() => {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) return;\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n    focusSinkRef.current!.focus({ preventScroll: true });\n  });\n\n  useImperativeHandle(ref, () => ({\n    scrollToColumn(idx: number) {\n      scrollToCell({ idx });\n    },\n    scrollToRow(rowIdx: number) {\n      const { current } = gridRef;\n      if (!current) return;\n      current.scrollTo({\n        top: rowIdx * rowHeight,\n        behavior: 'smooth'\n      });\n    },\n    selectCell\n  }));\n\n  /**\n  * callbacks\n  */\n  const handleColumnResize = useCallback((column: CalculatedColumn<R, SR>, width: number) => {\n    const newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n\n    onColumnResize?.(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n\n  const setDraggedOverRowIdx = useCallback((rowIdx?: number) => {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n\n  /**\n  * event handlers\n  */\n  function selectRow({ rowIdx, checked, isShiftClick }: SelectRowEvent) {\n    if (!onSelectedRowsChange) return;\n\n    assertIsValidKeyGetter(rowKeyGetter);\n    const newSelectedRows = new Set(selectedRows);\n    const row = rows[rowIdx];\n    if (isGroupRow(row)) {\n      for (const childRow of row.childRows) {\n        const rowKey = rowKeyGetter(childRow);\n        if (checked) {\n          newSelectedRows.add(rowKey);\n        } else {\n          newSelectedRows.delete(rowKey);\n        }\n      }\n      onSelectedRowsChange(newSelectedRows);\n      return;\n    }\n\n    const rowKey = rowKeyGetter(row);\n    if (checked) {\n      newSelectedRows.add(rowKey);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = Math.sign(rowIdx - previousRowIdx);\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          const row = rows[i];\n          if (isGroupRow(row)) continue;\n          newSelectedRows.add(rowKeyGetter(row));\n        }\n      }\n    } else {\n      newSelectedRows.delete(rowKey);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  function toggleGroup(expandedGroupId: unknown) {\n    if (!onExpandedGroupIdsChange) return;\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n    if (newExpandedGroupIds.has(expandedGroupId)) {\n      newExpandedGroupIds.delete(expandedGroupId);\n    } else {\n      newExpandedGroupIds.add(expandedGroupId);\n    }\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function handleKeyDown(event: React.KeyboardEvent<HTMLDivElement>) {\n    const { key, keyCode } = event;\n    const row = rows[selectedPosition.rowIdx];\n\n    if (\n      onPaste\n      && isCtrlKeyHeldDown(event)\n      && isCellWithinBounds(selectedPosition)\n      && !isGroupRow(row)\n      && selectedPosition.idx !== -1\n      && selectedPosition.mode === 'SELECT'\n    ) {\n      // event.key may differ by keyboard input language, so we use event.keyCode instead\n      // event.nativeEvent.code cannot be used either as it would break copy/paste for the DVORAK layout\n      const cKey = 67;\n      const vKey = 86;\n      if (keyCode === cKey) {\n        handleCopy();\n        return;\n      }\n      if (keyCode === vKey) {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (\n      isCellWithinBounds(selectedPosition)\n      && isGroupRow(row)\n      && selectedPosition.idx === -1\n      && (\n        // Collapse the current group row if it is focused and is in expanded state\n        (key === 'ArrowLeft' && row.isExpanded)\n        // Expand the current group row if it is focused and is in collapsed state\n        || (key === 'ArrowRight' && !row.isExpanded)\n      )) {\n      event.preventDefault(); // Prevents scrolling\n      toggleGroup(row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedCell(null);\n        closeEditor();\n        return;\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event: React.UIEvent<HTMLDivElement>) {\n    const { scrollTop, scrollLeft } = event.currentTarget;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll?.(event);\n  }\n\n  function getRawRowIdx(rowIdx: number) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx] as R) : rowIdx;\n  }\n\n  function commitEditorChanges() {\n    if (\n      columns[selectedPosition.idx]?.editor === undefined\n      || selectedPosition.mode === 'SELECT'\n      || selectedPosition.row === selectedPosition.originalRow) {\n      return;\n    }\n\n    const updatedRows = [...rawRows];\n    updatedRows[getRawRowIdx(selectedPosition.rowIdx)] = selectedPosition.row;\n    onRowsChange?.(updatedRows);\n  }\n\n  function handleCopy() {\n    const { idx, rowIdx } = selectedPosition;\n    setCopiedCell({ row: rawRows[getRawRowIdx(rowIdx)], columnKey: columns[idx].key });\n  }\n\n  function handlePaste() {\n    const { idx, rowIdx } = selectedPosition;\n    const targetRow = rawRows[getRawRowIdx(rowIdx)];\n    if (\n      !onPaste\n      || !onRowsChange\n      || copiedCell === null\n      || !isCellEditable(selectedPosition)\n    ) {\n      return;\n    }\n\n    const updatedTargetRow = onPaste({\n      sourceRow: copiedCell.row,\n      sourceColumnKey: copiedCell.columnKey,\n      targetRow,\n      targetColumnKey: columns[idx].key\n    });\n\n    const updatedRows = [...rawRows];\n    updatedRows[rowIdx] = updatedTargetRow;\n\n    onRowsChange(updatedRows);\n  }\n\n  function handleCellInput(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (!isCellWithinBounds(selectedPosition)) return;\n    const row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    const { key } = event;\n    const column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        // Custom editors can listen for the event and stop propagation to prevent commit\n        commitEditorChanges();\n        closeEditor();\n      }\n      return;\n    }\n\n    column.editorOptions?.onCellKeyDown?.(event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(({ idx, rowIdx }) => ({\n        idx,\n        rowIdx,\n        key,\n        mode: 'EDIT',\n        row,\n        originalRow: row\n      }));\n    }\n  }\n\n  function handleDragEnd() {\n    const overRowIdx = latestDraggedOverRowIdx.current;\n    if (overRowIdx === undefined || !onFill || !onRowsChange) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const startRowIndex = rowIdx < overRowIdx ? rowIdx + 1 : overRowIdx;\n    const endRowIndex = rowIdx < overRowIdx ? overRowIdx + 1 : rowIdx;\n    const targetRows = rawRows.slice(startRowIndex, endRowIndex);\n\n    const updatedTargetRows = onFill({ columnKey: columns[idx].key, sourceRow, targetRows });\n    const updatedRows = [...rawRows];\n    for (let i = startRowIndex; i < endRowIndex; i++) {\n      updatedRows[i] = updatedTargetRows[i - startRowIndex];\n    }\n    onRowsChange(updatedRows);\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event: React.MouseEvent<HTMLDivElement, MouseEvent>) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event: MouseEvent) {\n      // Trigger onMouseup in edge cases where we release the mouse button but `mouseup` isn't triggered,\n      // for example when releasing the mouse button outside the iframe the grid is rendered in.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event: React.MouseEvent<HTMLDivElement>) {\n    event.stopPropagation();\n    if (!onFill || !onRowsChange) return;\n\n    const { idx, rowIdx } = selectedPosition;\n    const sourceRow = rawRows[rowIdx];\n    const targetRows = rawRows.slice(rowIdx + 1);\n\n    const updatedTargetRows = onFill({ columnKey: columns[idx].key, sourceRow, targetRows });\n    const updatedRows = [...rawRows];\n    for (let i = rowIdx + 1; i < updatedRows.length; i++) {\n      updatedRows[i] = updatedTargetRows[i - rowIdx - 1];\n    }\n    onRowsChange(updatedRows);\n  }\n\n  function handleFormatterRowChange(rowIdx: number, row: Readonly<R>) {\n    const newRows = [...rawRows];\n    newRows[rowIdx] = row;\n    onRowsChange?.(newRows);\n  }\n\n  function handleEditorRowChange(row: Readonly<R>, commitChanges?: boolean) {\n    if (selectedPosition.mode === 'SELECT') return;\n    if (commitChanges) {\n      const updatedRows = [...rawRows];\n      updatedRows[getRawRowIdx(selectedPosition.rowIdx)] = row;\n      onRowsChange?.(updatedRows);\n      closeEditor();\n    } else {\n      setSelectedPosition(position => ({ ...position, row }));\n    }\n  }\n\n  function handleOnClose(commitChanges?: boolean) {\n    if (commitChanges) {\n      commitEditorChanges();\n    }\n    closeEditor();\n  }\n\n  /**\n   * utils\n   */\n  function isCellWithinBounds({ idx, rowIdx }: Position): boolean {\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position: Position): boolean {\n    return isCellWithinBounds(position)\n      && isSelectedCellEditable<R, SR>({ columns, rows, selectedPosition: position, isGroupRow });\n  }\n\n  function selectCell(position: Position, enableEditor = false): void {\n    if (!isCellWithinBounds(position)) return;\n    commitEditorChanges();\n\n    if (enableEditor && isCellEditable(position)) {\n      const row = rows[position.rowIdx] as R;\n      setSelectedPosition({ ...position, mode: 'EDIT', key: null, row, originalRow: row });\n    } else {\n      setSelectedPosition({ ...position, mode: 'SELECT' });\n    }\n    onSelectedCellChange?.({ ...position });\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(({ idx, rowIdx }) => ({ idx, rowIdx, mode: 'SELECT' }));\n  }\n\n  function scrollToCell({ idx, rowIdx }: Partial<Position>): void {\n    const { current } = gridRef;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      const { clientWidth } = current;\n      const { left, width } = columns[idx];\n      const isCellAtLeftBoundary = left < scrollLeft + width + totalFrozenColumnWidth;\n      const isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        const newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key: string, ctrlKey: boolean, shiftKey: boolean): Position {\n    const { idx, rowIdx } = selectedPosition;\n    const row = rows[rowIdx];\n    const isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1;\n\n    // If a group row is focused, and it is collapsed, move to the parent group row (if there is one).\n    if (\n      key === 'ArrowLeft'\n      && isRowSelected\n      && isGroupRow(row)\n      && !row.isExpanded\n      && row.level !== 0\n    ) {\n      let parentRowIdx = -1;\n      for (let i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n      if (parentRowIdx !== -1) {\n        return { idx, rowIdx: parentRowIdx };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return { idx, rowIdx: rowIdx - 1 };\n      case 'ArrowDown':\n        return { idx, rowIdx: rowIdx + 1 };\n      case 'ArrowLeft':\n        return { idx: idx - 1, rowIdx };\n      case 'ArrowRight':\n        return { idx: idx + 1, rowIdx };\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? { idx: columns.length - 1, rowIdx: rows.length - 1 } : { idx: 0, rowIdx: 0 };\n        }\n        return { idx: idx + (shiftKey ? -1 : 1), rowIdx };\n      case 'Home':\n        // If row is selected then move focus to the first row\n        if (isRowSelected) return { idx, rowIdx: 0 };\n        return ctrlKey ? { idx: 0, rowIdx: 0 } : { idx: 0, rowIdx };\n      case 'End':\n        // If row is selected then move focus to the last row.\n        if (isRowSelected) return { idx, rowIdx: rows.length - 1 };\n        return ctrlKey ? { idx: columns.length - 1, rowIdx: rows.length - 1 } : { idx: columns.length - 1, rowIdx };\n      case 'PageUp':\n        return { idx, rowIdx: rowIdx - Math.floor(clientHeight / rowHeight) };\n      case 'PageDown':\n        return { idx, rowIdx: rowIdx + Math.floor(clientHeight / rowHeight) };\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event: React.KeyboardEvent<HTMLDivElement>) {\n    if (selectedPosition.mode === 'EDIT') {\n      const onNavigation = columns[selectedPosition.idx].editorOptions?.onNavigation ?? onEditorNavigation;\n      if (!onNavigation(event)) return;\n    }\n    const { key, shiftKey } = event;\n    const ctrlKey = isCtrlKeyHeldDown(event);\n    let nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n    let mode = cellNavigationMode;\n    if (key === 'Tab') {\n      // If we are in a position to leave the grid, stop editing but stay in that cell\n      if (canExitGrid({ shiftKey, cellNavigationMode, columns, rowsCount: rows.length, selectedPosition })) {\n        commitEditorChanges();\n        // Allow focus to leave the grid so the next control in the tab order can be focused\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE'\n        ? 'CHANGE_ROW'\n        : cellNavigationMode;\n    }\n\n    // Do not allow focus to leave\n    event.preventDefault();\n\n    nextPosition = getNextSelectedCellPosition<R, SR>({\n      columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition\n    });\n\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx: number): number | undefined {\n    if (draggedOverRowIdx === undefined) return;\n    const { rowIdx } = selectedPosition;\n\n    const isDraggedOver = rowIdx < draggedOverRowIdx\n      ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx\n      : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx: number): SelectedCellProps | EditCellProps<R> | undefined {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorProps: {\n          editorPortalTarget,\n          rowHeight,\n          row: selectedPosition.row,\n          onRowChange: handleEditorRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition)\n        ? { onMouseDown: handleMouseDown, onDoubleClick: handleDoubleClick }\n        : undefined\n    };\n  }\n\n  function getViewportRows() {\n    const rowElements = [];\n    let startRowIndex = 0;\n    for (let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      const row = rows[rowIdx];\n      const top = rowIdx * rowHeight + totalHeaderHeight;\n      if (isGroupRow(row)) {\n        ({ startRowIndex } = row);\n        rowElements.push(\n          <GroupRowRenderer<R, SR>\n            aria-level={row.level + 1} // aria-level is 1-based\n            aria-setsize={row.setSize}\n            aria-posinset={row.posInSet + 1} // aria-posinset is 1-based\n            aria-rowindex={headerRowsCount + startRowIndex + 1} // aria-rowindex is 1 based\n            key={row.id}\n            id={row.id}\n            groupKey={row.groupKey}\n            viewportColumns={viewportColumns}\n            childRows={row.childRows}\n            rowIdx={rowIdx}\n            top={top}\n            level={row.level}\n            isExpanded={row.isExpanded}\n            selectedCellIdx={selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined}\n            isRowSelected={isSelectable && row.childRows.every(cr => selectedRows?.has(rowKeyGetter!(cr)))}\n            onFocus={selectedPosition.rowIdx === rowIdx ? handleFocus : undefined}\n            onKeyDown={selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined}\n            selectCell={selectCellWrapper}\n            selectRow={selectRowWrapper}\n            toggleGroup={toggleGroupWrapper}\n          />\n        );\n        continue;\n      }\n\n      startRowIndex++;\n      let key: React.Key = hasGroups ? startRowIndex : rowIdx;\n      let isRowSelected = false;\n      if (typeof rowKeyGetter === 'function') {\n        key = rowKeyGetter(row);\n        isRowSelected = selectedRows?.has(key) ?? false;\n      }\n\n      rowElements.push(\n        <RowRenderer\n          aria-rowindex={headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1} // aria-rowindex is 1 based\n          aria-selected={isSelectable ? isRowSelected : undefined}\n          key={key}\n          rowIdx={rowIdx}\n          row={row}\n          viewportColumns={viewportColumns}\n          isRowSelected={isRowSelected}\n          onRowClick={onRowClick}\n          rowClass={rowClass}\n          top={top}\n          copiedCellIdx={copiedCell !== null && copiedCell.row === row ? columns.findIndex(c => c.key === copiedCell.columnKey) : undefined}\n          draggedOverCellIdx={getDraggedOverCellIdx(rowIdx)}\n          setDraggedOverRowIdx={isDragging ? setDraggedOverRowIdx : undefined}\n          selectedCellProps={getSelectedCellProps(rowIdx)}\n          onRowChange={handleFormatterRowChangeWrapper}\n          selectCell={selectCellWrapper}\n          selectRow={selectRowWrapper}\n        />\n      );\n    }\n\n    return rowElements;\n  }\n\n  // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition({ idx: -1, rowIdx: -1, mode: 'SELECT' });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (selectedPosition.mode === 'EDIT' && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n    // Discard changes if rows are updated from outside\n    closeEditor();\n  }\n\n  return (\n    <div\n      role={hasGroups ? 'treegrid' : 'grid'}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-describedby={ariaDescribedBy}\n      aria-multiselectable={isSelectable ? true : undefined}\n      aria-colcount={columns.length}\n      aria-rowcount={headerRowsCount + rowsCount + summaryRowsCount}\n      className={clsx('rdg', { 'rdg-viewport-dragging': isDragging }, className)}\n      style={{\n        ...style,\n        '--header-row-height': `${headerRowHeight}px`,\n        '--filter-row-height': `${headerFiltersHeight}px`,\n        '--row-width': `${totalColumnWidth}px`,\n        '--row-height': `${rowHeight}px`\n      } as unknown as React.CSSProperties}\n      ref={gridRef}\n      onScroll={handleScroll}\n    >\n      <HeaderRow<R, SR>\n        rowKeyGetter={rowKeyGetter}\n        rows={rawRows}\n        columns={viewportColumns}\n        onColumnResize={handleColumnResize}\n        allRowsSelected={selectedRows?.size === rawRows.length}\n        onSelectedRowsChange={onSelectedRowsChange}\n        sortColumn={sortColumn}\n        sortDirection={sortDirection}\n        onSort={onSort}\n      />\n      {enableFilterRow && (\n        <FilterRow<R, SR>\n          columns={viewportColumns}\n          filters={filters}\n          onFiltersChange={onFiltersChange}\n        />\n      )}\n      {rows.length === 0 && EmptyRowsRenderer ? <EmptyRowsRenderer /> : (\n        <>\n          <div\n            ref={focusSinkRef}\n            tabIndex={0}\n            className=\"rdg-focus-sink\"\n            onKeyDown={handleKeyDown}\n          />\n          <div style={{ height: Math.max(rows.length * rowHeight, clientHeight) }} />\n          {getViewportRows()}\n          {summaryRows?.map((row, rowIdx) => (\n            <SummaryRow<R, SR>\n              aria-rowindex={headerRowsCount + rowsCount + rowIdx + 1}\n              key={rowIdx}\n              rowIdx={rowIdx}\n              row={row}\n              bottom={rowHeight * (summaryRows.length - 1 - rowIdx)}\n              viewportColumns={viewportColumns}\n            />\n          ))}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default forwardRef(DataGrid) as <R, SR = unknown>(props: DataGridProps<R, SR> & React.RefAttributes<DataGridHandle>) => JSX.Element;\n","import type { EditorProps } from '../types';\n\nfunction autoFocusAndSelect(input: HTMLInputElement | null) {\n  input?.focus();\n  input?.select();\n}\n\nexport default function TextEditor<TRow, TSummaryRow = unknown>({\n  row,\n  column,\n  onRowChange,\n  onClose\n}: EditorProps<TRow, TSummaryRow>) {\n  return (\n    <input\n      className=\"rdg-text-editor\"\n      ref={autoFocusAndSelect}\n      value={row[column.key as keyof TRow] as unknown as string}\n      onChange={event => onRowChange({ ...row, [column.key]: event.target.value })}\n      onBlur={() => onClose(true)}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}