'use strict';/*
 [@artdeco/]protypes: Joins Multiple Implementations Into A Single Class.

 Copyright (C) 2020  Art Deco Code Limited

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
class l extends Error{constructor(a){super(`${a} is only supported in the paid version.`)}get code(){return"NOTPAID"}};const u=(a,b,c=null)=>{a=a.prototype;c=r(a,[],c);const d={};a=Object.getOwnPropertyDescriptors(a);Object.defineProperties(d,a);t(c,d,b);return d},t=(a,b,c={})=>{let {methodDecorators:d=[],mergeGettersSetters:e=!1,overrideTarget:g=!1}=c;const {bindings:{bindMethods:k=!1,bindProtypeMethods:q=k,bindClassMethods:m=k}={}}=c;Array.isArray(d)||(d=[d]);a.forEach(n=>{n=v(n,(p,f)=>{var h=Object.getOwnPropertyDescriptor(b,p);const A=f.get||f.set;if(h&&(h.get||h.set)&&e){if(g?w(f,h):w(h,f))throw new l("Merging getters and setters");
if(g)return f}else if(!h||g){if(A&&e)throw new l("Merging getters and setters");({value:h}=f);if("function"==typeof h&&(d.forEach(()=>{throw new l("Method decorators");}),(q||m)&&"constructor"!=p))throw new l("Binding");p=x({get:void 0,set:void 0,value:void 0});return f={...f,...p}}});Object.defineProperties(b,n)})},v=(a,b)=>{a=Object.getOwnPropertyDescriptors(a);return Object.entries(a).reduce((c,[d,e])=>{e=b(d,e);if(!e)return c;c[d]=e;return c},{})},w=(a,b)=>{let c,d;a.get&&!a.set&&b.set?d=b.set:
a.set&&!a.get&&b.get&&(c=b.get);return c||d?(b=x({get:c,set:d}),{...a,...b}):null},r=(a,b=[],c=null)=>{if(!a)return b;a=a.__proto__;if(!a||a.constructor===Object||a.constructor===c)return b;b.unshift(a);return r(a,b,c)},x=a=>Object.entries(a).reduce((b,[c,d])=>{if(void 0===d)return b;b[c]=d;return b},{});const y=Symbol("protypes::__implementations"),z=Symbol("protypes::__name"),B=(a,b)=>{const c=r(a.prototype).map(({[z]:e})=>e),d=[a,...b].reduce((e,g)=>{let {prototype:k={},prototype:{[z]:q=null,[y]:m}=k}=g;m||(m=r(k).map(({[z]:n})=>n));e.push(q,...m);return e},c).filter(Boolean).filter((e,g,k)=>k.indexOf(e)==g);Object.defineProperty(a.prototype,y,{get(){return[...d]}})};module.exports={_subtype:function(a,b,...c){b=b||{};let {setProtypesPrototype:d=!1,fixTargetGettersSetters:e,bindings:{bindMethods:g=!1,bindTargetMethods:k=g,bindInhertiedMethods:q=g}={}}=b;!0===e&&(e="before");const m=a.prototype,n=[],p=c.map(f=>{if("function"==typeof f)f=u(f,void 0,a);else{const h=u({prototype:f});d&&Object.setPrototypeOf(f,m.__proto__);f=h;n.push(f)}return f},[]);if("before"==e)throw new l("fixTargetGettersSetters");if(q)throw new l("Target inherited method bindings");if(k)throw new l("Target method bindings");
t(p,a.prototype,b);if("after"==e)throw new l("fixTargetGettersSetters");b=c.map(f=>"function"!=typeof f?{prototype:f}:f);B(a,b)},_callAbstract:function(a,b,c){const d=(Object.getOwnPropertyDescriptor(c.__proto__,b)||{}).value;b=null;"function"!=typeof d||/{\s*}$/.test(d.toString())||(b=function(...e){d.call(this,...e);return a.call(this,...e)});return b},_is:(a,b)=>(a[y]||[]).includes(b),_$name:z,["_decorator"](){}};
