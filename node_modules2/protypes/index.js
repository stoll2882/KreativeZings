const { _subtype, _decorator, _callAbstract, _is, _$name } = require('./compile/protypes')

/**
 * Copy properties from prototypes into the class's prototype.
 * The target class's prototype is modified itself.
 * @param {new (...args: *[]) => Object} TargetClass The class whose prototype should be updated with methods from implementations.
 * @param {Options} opts Options for extending.
 * - `[methodDecorators]` _!Array&lt;!$decorator&gt;\|$decorator?_ An array with functions that will decorate methods when new descriptors
 * get assigned to the prototype of a target.
 * - `[setProtypesPrototype=false]` _boolean?_ When passing protypes, set target's prototype as their own, so that
 * `super` calls can be made. This will update the protype's prototype
 * every time the `subtype` method is called on them, so this should be
 * used only when a class is subtyped once. Default `false`.
 * - `[mergeGettersSetters=false]` _boolean?_ When copying getters and setters that are missing their counterpart, find
 * their sibling in the prototype chain and fill in the slot. If this is not
 * done, a single getter without setter will prevent a setter from being
 * called on a parent class. Default `false`.
 * - `[fixTargetGettersSetters]` _'before'\|'after'\|true?_ Looks up the prototypical chain of the target to merge its getters and
 * setters with missing counterparts, if such are found. This allows to inherit
 * individual getters and setters. The value can be either `before` or `after`,
 * such that the fix will be performed either before or after subtyping. If it
 * is done before, then no subtype will be able to fill in the slot, and if
 * after, then if any supertype had filled in the slot, it won't be updated.
 * When passing a boolean `true`, the `before` strategy is chosen.
 * - `[bindings]` _!BindingOptions?_ Options for binding methods. When binding is enabled, all methods of applicable
 * instances will be re-described with `get` property of the field descriptor,
 * which wraps the actual method (its `value` property) to return the bound one.
 * This feature is available only in the `paid` version.
 * - `[overrideTarget=false]` _boolean?_ When protypes' methods are already present in the target, override them.
 * By default, this option is set to false which means that all methods on the
 * target will have precedence over those found in protypes. Default `false`.
 * @param {...!Object<string, *>|function(new: Object, ...*)} Implementations The implementations in form of protypes or constructors.
 * @example
 * ```js
 * import { subtype } from 'protypes'
 *
 * ```
 * This is the class that will be extended (subtyped):
 * ```js
 * class Target {}
 *
 * ```
 * The supertype from whose prototype properties will be compied:
 * ```js
 * class Specialised {
 *   get example() {
 *     return 'hello-world'
 *   }
 * }
 * ```
 * Instead of full class, a simple object (protype) can be used:
 * ```js
 * let Protype = {
 *   example2() { return 'protype run' },
 * }
 *
 * subtype(Target, null, Specialised, Protype)
 * const t = new Target()
 *
 * console.log(t.example)
 * ```
 * "hello world" - from `Specialised`
 * ```js
 * console.log(t.example2())
 * ```
 * "protype run" - from `Protype`
 * @return {void} Doesn't return anything. Updates the class directly.
 */
function $subtype(TargetClass, opts, ...Implementations) {
  return _subtype(TargetClass, opts, ...Implementations)
}

/**
 * Method decorators will be called prior to assigning a new descriptor on the
 * target's prototype and allow to set up pre- and post- logic on methods.
 * This is just a signature type and not a real function.
 * @param {!Function} method The method that potentially can be decorated.
 * @param {string} propName The name of the member slot which is being assigned.
 * @param {!Object} target This is the prototype on which the descriptor will be assigned.
 * @return {Function} The decorated function or null.
 */
function $decorator(method, propName, target) {
  return _decorator(method, propName, target)
}

/**
 * This decorator will call immediate ABC (abstract) class that is extended
 * by the target class. Can be used for run-time type checking.
 * @param {!Function} method The method that potentially can be decorated.
 * @param {string} propName The name of the member slot which is being assigned.
 * @param {!Object} target This is the prototype on which the descriptor will be assigned.
 * @return {Function} The decorated function or null.
 */
function $callAbstract(method, propName, target) {
  return _callAbstract(method, propName, target)
}

/**
 * Checks whether the instance was created by a constructor which
 * has been subtyped with a protype or class that was assigned the
 * `name` symbol from this library.
 * @param {!Object} instance The instance that was subtyped with `protypes` to check the kind of.
 * @param {string} kind The required kind that should be checked.
 * @return {boolean} True if the instance is of the kind given and false otherwise.
 */
function $is(instance, kind) {
  return _is(instance, kind)
}

module.exports.$name = _$name

module.exports.subtype = $subtype
module.exports.decorator = $decorator
module.exports.callAbstract = $callAbstract
module.exports.is = $is

/**
 * @typedef {$subtype} subtype
 * @typedef {$decorator} decorator
 * @typedef {$callAbstract} callAbstract
 * @typedef {$is} is
 */

/* typal types/index.xml */
/**
 * @typedef {Object} Options `＠record` The options used in the library.
 * @prop {!Array<!$decorator>|$decorator} [methodDecorators] An array with functions that will decorate methods when new descriptors
 * get assigned to the prototype of a target.
 * @prop {boolean} [setProtypesPrototype=false] When passing protypes, set target's prototype as their own, so that
 * `super` calls can be made. This will update the protype's prototype
 * every time the `subtype` method is called on them, so this should be
 * used only when a class is subtyped once. Default `false`.
 * @prop {boolean} [mergeGettersSetters=false] When copying getters and setters that are missing their counterpart, find
 * their sibling in the prototype chain and fill in the slot. If this is not
 * done, a single getter without setter will prevent a setter from being
 * called on a parent class. Default `false`.
 * @prop {'before'|'after'|true} [fixTargetGettersSetters] Looks up the prototypical chain of the target to merge its getters and
 * setters with missing counterparts, if such are found. This allows to inherit
 * individual getters and setters. The value can be either `before` or `after`,
 * such that the fix will be performed either before or after subtyping. If it
 * is done before, then no subtype will be able to fill in the slot, and if
 * after, then if any supertype had filled in the slot, it won't be updated.
 * When passing a boolean `true`, the `before` strategy is chosen.
 * @prop {!BindingOptions} [bindings] Options for binding methods. When binding is enabled, all methods of applicable
 * instances will be re-described with `get` property of the field descriptor,
 * which wraps the actual method (its `value` property) to return the bound one.
 * This feature is available only in the `paid` version.
 * @prop {boolean} [overrideTarget=false] When protypes' methods are already present in the target, override them.
 * By default, this option is set to false which means that all methods on the
 * target will have precedence over those found in protypes. Default `false`.
 * @typedef {Object} BindingOptions `＠record` Options to bind methods to instances.
 * @prop {boolean} [bindMethods=false] Binds all methods:
 * - in protypes and classes, i.e. structs passed to the `subtype` method.
 * - in target's own properties.
 * - in the whole of target's inheritance chain so that any inherited method is also bound. Default `false`.
 * @prop {boolean} [bindProtypeMethods=false] Binds protypes' methods to the instance. Default `false`.
 * @prop {boolean} [bindClassMethods=false] Binds methods of classes passed to `subtype` to the instance. Default `false`.
 * @prop {boolean} [bindTargetMethods=false] Allows to bind methods to the target to their instance even prior to instantiating. Default `false`.
 * @prop {boolean} [bindInhertiedMethods=false] Scans through the inheritance chain of the target (and supertype classes) and wraps
 * methods in getters that will return their bound versions. Default `false`.
 * @typedef {!Symbol} $name The symbol to be used to assign name to protypes and classes to check using
 * the is method afterwards.
 */
