

<div align="center"><p align="center">

# Protypes

_by <a href="https://www.artd.eco">Art Deco&trade;</a>_ &mdash;<a href="https://www.artd.eco">Professional Software Development Company In London</a>.

[![npm version](https://badge.fury.io/js/protypes.svg)](https://www.npmjs.com/package/protypes)
<a href="https://gitlab.com/artdeco/protypes/-/commits/master">
  <img src="https://gitlab.com/artdeco/protypes/badges/master/pipeline.svg" alt="Pipeline Badge">
</a>
</p></div>

> **PLEASE REFER TO THE FULL DOCUMENTATION ON THE [PROTYPES](https://artdeco.software/protypes/) HOMEPAGE!**<br/>
> Information provided in this README has illustrative purpose only, is limited and doesn't describe API of this library in details.

`protypes` is: Joins Multiple Implementations Into A Single Class.

```sh
yarn add protypes
npm i protypes
```

## Table of Contents

- [Table of Contents](#table-of-contents)
- [What Is Protype?](#what-is-protype)
- [API](#api)
- [`subtype(Target, opts, ...(Protype|Class))`](#subtypetarget-opts-protypeclass)
  * [Options](#options)
- [`is(obj, protypeName)`](#isobj-protypename)
- [Copyright & License](#copyright--license)

<div align="center"><p align="center"><a href="#table-of-contents">
  <img alt="section break" src="https://artdeco.gitlab.io/protypes/section-breaks/0.svg">
</a></p></div>

## What Is Protype?

JavaScript is prototype-based language. Prototypes are objects from which other objects are created, for example, using `Object.create()`. Since introduction of classes in ES5 standard, the programming was largely class-based, however there's another possibility: via protypes.

A **protype** is the type of prototypes. It's like a class but simpler, denoted in a standard object. Class-based approach is really a syntactic sugar over prototypes. There are limitations to the standard hierarchical model, such that larger systems can not be adequately expressed in terms of gradually refining implementations of specialising interfaces, and types need to be subtyped via alternative routes, that is, protypes, which simply allow to copy methods into objects without vertical inheritance.

```js
// Standard class-based model:

class Doer {
  do() {
    console.log('doing work')
  }
}
class Writer {
  write() {
    console.log('hello world')
  }
}

// `MyClass` can inherit from `Doer`, but
// how can we make it extend `Writer`, too?
class MyClass extends Doer {}

// Absence of multiple inheritance
// is a limitation of JavaScript
// solved by *Protypes*.
```

There's no support for multiple inheritance in JS, so the code reuse for types that specialise in multiple things isn't possible without a dynamic solution such that is provided by this library. *Protypes* allows to **subtype** types from their supertypes, i.e. to inherit methods horizontally rather than vertically:

```js
import { subtype } from '../..'

const Doer = {        // <- protype
  do() {
    console.log('doing work')
  },
}
const Writer = {      // <- protype
  write() {
    console.log('hello world')
  },
}
class MyClass {} // <- target class

subtype(MyClass, null, Doer, Writer)
const c = new MyClass()
c.do()
c.write()
```
```
doing work
hello world
```

As you can see, **protypes** is a more natural approach to prototype-based programming that is facilitated by JavaScript. Only because of the lack of theoretical background in programming and the mainstream approach to development that involves classes, they've been used very rarely. But once you discover their utility, you will fully realise their potential. Plus, nobody is taking classes away, and protypes can be mixed in any class with its hierarchical inheritance structure. When it becomes illogical to work "in depth", then protypes with their "in width" approach will come to the rescue.

<div align="center"><p align="center"><a href="#table-of-contents">
  <img alt="section break" src="https://artdeco.gitlab.io/protypes/section-breaks/1.svg">
</a></p></div>

## API

The package is available by importing its named functions and symbols:

```js
import { subtype, is, $name } from 'protypes'
```

They are briefly described on this page, but the full description is found in the [official documentation](https://artdeco.software/protypes/).

<div align="center"><p align="center"><a href="#table-of-contents">
  <img alt="section break" src="https://artdeco.gitlab.io/protypes/section-breaks/2.svg">
</a></p></div>

## `subtype(Target, opts, ...(Protype|Class))`

Subtyping is a feature of _OOP_ which allows objects of one type to be accepted in contexts expecting another type (class) [[Sny86](https://dl.acm.org/doi/10.1145/960112.28702)]. If you ever used down-casting, you were using this feature. It is also the basis for polymorphism. Just see the example below to immediately understand what subtyping is:

```js
class Doer {
  do() {
    console.log('doing work')
  }
}
class MyClass extends Doer {}

/**
 * The main function.
 * @param {Doer} doer
 */
function main(doer) {
  doer.do()
}

const c = new MyClass()

main(c)
```

We defined a class, _Doer_, and implemented the `do` method in it. We also declared a function `main` that accepts a _Doer_ as its argument. We then proceed to create a new instance of a _MyClass_ which extends the _Doer_ class. And although the function `main` receives this instance, it's still type-sound since the instance is a subtype of _Doer_ (which is a supertype of _MyClass_). This is what subtyping is.

```
doing work
```

When we want to extend classes with protypes (or other classes), we're subtyping the target class by those protypes (or classes). In formal notation, it would be written as `Target <: Protype` (`Subtype <: Supertype`). The target can thus become a subtype of any number of other types. Objects created via such class constructor, will inherit all methods from all its supertypes. Inheritance doesn't necessary mean standard top-down sharing of methods via the `extends` keyword, but can also mean horizontal borrowing of methods from protypes.

<table>
<thead>
<tr><th>Source</th><th>Output</th></tr>
</thead>
<tbody>
<tr><td>

```js
import { subtype } from 'protypes'

class Doer {
  do() {
    this._isDoing = true
    console.log('doing work')
  }
  get isDoing() {
    return this._isDoing
  }
}
const Writer = {
  what: 'world',
  write() {
    console.log('hello %s', this.what)
  },
}
class MyClass {} // <- target class

subtype(MyClass, null, Doer, Writer)
const c = new MyClass()
c.do()
c.what = 'WORLD'
c.write()
console.log('is doing: %s', c.isDoing)
```
</td><td>

```
doing work
hello WORLD
is doing: true
```
</td>
</tr>
</tbody>
</table>

The subtype accepts the target class as the first argument, some options (if no options are required, `null` needs to be passed), and then the list of all protypes and classes that need to be subtyped. Their methods, getters, setters and even static data fields will be copied across.

There are some nuances that need to be considered, such as [using super keyword](https://artdeco.software/protypes/super.html), which is actually statically bound to the prototype's instance, and [merging getters and setters](https://artdeco.software/protypes/merging-getters-and-setters.html). You can follow the links to read about these intricacies on the package's documentation website.


### Options

The list of options that can be used with the `subtype` method includes:


<details>
<summary><strong>setProtypesPrototype</strong>: Protypes will usually come in form of simple objects. To be able to use <code>super.</code> in their methods, their prototype needs to be set to the target's, but this can be done only once since <code>super</code> is statically bound. Show example of setting prototypes of protypes.</summary>

```js
import { subtype } from 'protypes'

class Parent {
  method() {
    console.log('parent method')
  }
}
class Target extends Parent {}
let Protype = {
  run() {
    super.method()
  },
}
subtype(Target, null, Protype)
let t = new Target()
try {
  t.run()
} catch (err) {
  console.log(err.message)
}
// fix super
class Target2 extends Parent {}
subtype(Target2, {
  setProtypesPrototype: true,
}, Protype)
t = new Target2()
t.run()
```
```
(intermediate value).method is not a function
parent method
```
</details>

<details>
<summary>[<code>paid</code>] <strong>methodDecorators</strong>: An array of decorators that can wrap methods which are being assigned to the prototype of the target class. Show example of method decorators.</summary>

```js
import { subtype } from 'protypes'

class Target {}
let Protype = {
  run(arg) {
    console.log('running protype with %s', arg)
  },
}
const decorator = (method, propName) => {
  return function(...args) {
    console.log('pre-condition on %s', propName)
    const res = method.call(this, ...args)
    console.log('post-condition on %s', propName)
    return res
  }
}
subtype(Target, {
  methodDecorators: [decorator],
}, Protype)
const t = new Target()
t.run('hello')
```
```
pre-condition on run
running protype with hello
post-condition on run
```
</details>


<details>
<summary>[<code>paid</code>] <strong>mergeGettersSetters</strong>: When a class or a protype specifies only a getter or setter without its counter-part, the inheritance will be broken. This option allows to look up missing getters/setters in the prototype chain of the target. Show example.</summary>

<table>
<thead>
<tr><th>Without Merging</th><th>With Merging</th></tr>
</thead>
<tbody>
<tr><td>

```js
import { subtype } from 'protypes'

class Target {
  set example(e) {
    this._e = e
  }
}

let Protype = {
  get example() {
    return this._e
  },
}

subtype(Target, null, Protype)
let t = new Target()
t.example = 'example'



// expect undefined
console.log(t.example)
```
```
undefined
```
</td><td>

```js
import { subtype } from 'protypes'

class Target2 {
  set example(e) {
    this._e = e
  }
}

let Protype = {
  get example() {
    return this._e
  },
}

subtype(Target2, {
  mergeGettersSetters: true,
}, Protype)
let t2 = new Target2()
t2.example = 'example'

// expect "example"
console.log(t2.example)
```
```
example
```
</td>
</tr>
</tbody>
</table>

</details>


<details>
<summary>[<code>paid</code>] <strong>fixTargetGettersSetters</strong>: Similar to the previous option, but applies to the target itself. Can be applied before or after assignment of protypes/classes. Click to preview example code.</summary>

<table>
<thead>
<tr><th>Without Fix</th><th>With Fix</th></tr>
</thead>
<tbody>
<tr><td>

```js
import { subtype } from 'protypes'

class Parent {
  get example() {
    return this._e
  }
}
class Target extends Parent{
  set example(e) {
    this._e = e
  }
}

subtype(Target, null)
let t = new Target()
t.example = 'example'
console.log(t.example)
```
```
undefined
```
</td><td>

```js
import { subtype } from 'protypes'

class Parent {
  get example() {
    return this._e
  }
}
class Target extends Parent{
  set example(e) {
    this._e = e
  }
}

subtype(Target, {
  fixTargetGettersSetters: true,
})
let t = new Target()
t.example = 'example'
console.log(t.example)
```
```
example
```
</td>
</tr>
</tbody>
</table>

</details>

<details>
<summary>[<code>paid</code>] <strong>bindings</strong>: Allows to set bindings on method's class automatically, so that they can be destructured and still access the <code>this</code> keyword inside of them.</summary>

```js
import { subtype } from 'protypes'

class Target {
  get target() { return 'target' }
  test() { console.log('test:', this.target) }
}

subtype(Target, {
  bindings: {
    bindMethods: true,
  },
}, {
  get protype() { return 'protype' },
  example() { console.log('example: %s, %s',
    this.protype, this.target) },
})

let t = new Target()
const { example, test } = t
test()
example()
```
```
test: target
example: protype, target
```

</details>



















<div align="center"><p align="center"><a href="#table-of-contents">
  <img alt="section break" src="https://artdeco.gitlab.io/protypes/section-breaks/3.svg">
</a></p></div>


## `is(obj, protypeName)`

To determine whether the given instance's class is Proto|Class or a subclass of Proto|Class. In plain JS, we'd use `instanceof` however with multiple inheritance / subtyping this does not work as the methods are copied across into the target class. The `is` method from this library can be used to determine whether a Protype (or Class) has been implemented by the given object.

<table>
<thead>
<tr><th>Source</th><th>Output</th></tr>
</thead>
<tbody>
<tr><td>

```js
import {
  subtype, $name, is,
} from 'protypes'

class Doer {
  get [$name]() { return 'Doer' }
}
const Writer = {
  [$name]: 'Writer',
}
class MyClass {} // <- target class

subtype(MyClass, null, Doer, Writer)
const c = new MyClass()
console.log('is Writer:',
  is(c, 'Writer'))
console.log('is Doer:',
  is(c, 'Doer'))
console.log('is Member:',
  is(c, 'Member'))
```
</td><td>

```
is Writer: true
is Doer: true
is Member: false
```
</td>
</tr>
</tbody>
</table>

The check is performed on strings currently, but in the future version it'll be extended to passing of actual protypes. The reason for this limitation is that with non-string based implementation of the `is` method, chances are high you might run into circular dependencies that would break the system. The `name` must be defined on protypes and classes using the special `$name` symbol exported by the library.

<div align="center"><p align="center"><a href="#table-of-contents">
  <img alt="section break" src="https://artdeco.gitlab.io/protypes/section-breaks/4.svg">
</a></p></div>







## Copyright & License

The public free version of the package is provided under the **GNU Affero General Public License v3.0** so that you can use it in AGPL-compatible projects. The full version requires purchasing of a license key and is distributed under an EULA terms. Please contact [Art Deco](https://keybase.io/artdeco) on Keybase chat to purchase the key.

<table>
  <tr>
    <th width="100px">
      <a href="https://www.artd.eco">
        <img width="100" src="https://artdeco.gitlab.io/assets/logo-100.png" alt="Art Deco">
      </a>
    </th>
    <th>© <a href="https://www.artd.eco">Art Deco™</a>   2020</th>
  </tr>
</table>

<div align="center"><p align="center"><a href="#table-of-contents">
  <img alt="section break" src="https://artdeco.gitlab.io/protypes/section-breaks/-1.svg">
</a></p></div>